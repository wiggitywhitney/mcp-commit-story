# Task ID: 48
# Title: Implement Working Chat Collection
# Status: pending
# Dependencies: 45, 46, 47
# Priority: high
# Description: Refactor the existing collect_chat_history() implementation in context_collection.py with actual Cursor SQLite extraction functionality to retrieve chat data from the database.
# Details:
This task refactors the existing chat collection functionality by replacing the placeholder implementation with a working version that extracts data from Cursor's SQLite database:

1. **Refactor the Existing collect_chat_history Function**:
   - Preserve the current function signature: `collect_chat_history(since_commit=None, max_messages_back=150) -> ChatHistory`
   - Maintain compatibility with existing callers in journal_workflow.py and journal_orchestrator.py
   - Keep all existing telemetry decorators and error handling patterns
   - Fill in the TODO comment with actual implementation

```python
@trace_mcp_operation
def collect_chat_history(since_commit=None, max_messages_back=150):
    """
    Collect chat history from Cursor's SQLite database.
    
    Args:
        since_commit: Optional commit hash to filter messages after a certain point
        max_messages_back: Maximum number of messages to retrieve
        
    Returns:
        ChatHistory object containing the extracted chat data or None if unavailable
    """
    try:
        # Get workspace path from config or detect automatically
        workspace_path = get_cursor_workspace_path()
        
        # Query the database using the direct database query function
        chat_data = query_cursor_chat_database(workspace_path, max_messages_back)
        
        if not chat_data:
            logger.info("No chat data found in Cursor database")
            return None
            
        # Apply boundary detection to segment conversations
        boundary_detector = ChatBoundaryDetector()
        segmented_chats = boundary_detector.segment_conversations(chat_data)
        
        # Format the chat data for journal integration (maintaining ChatHistory return type)
        formatted_chats = []
        for segment in segmented_chats:
            formatted_segment = ChatConversation(
                timestamp=segment["timestamp"],
                topic=segment["topic"],
                messages=segment["messages"],
                summary=segment.get("summary", "")
            )
            formatted_chats.append(formatted_segment)
            
        return ChatHistory(
            source="cursor_chat",
            conversations=formatted_chats
        )
    except Exception as e:
        logger.error(f"Error collecting chat history: {str(e)}")
        if config.get("debug", False):
            logger.exception("Detailed error:")
        return None
```

2. **Error Handling for Missing/Inaccessible Databases**:
   - Implement robust error handling for cases where:
     - The Cursor database file doesn't exist
     - The database exists but is inaccessible (permissions)
     - The database schema doesn't match expectations
     - The workspace path is invalid or not detected

3. **Integration with Boundary Detection**:
   - Utilize the ChatBoundaryDetector class to properly segment conversations
   - Ensure proper handling of conversation context and topic changes
   - Apply the max_messages_back parameter to limit conversation history

4. **Workspace Detection Logic**:
   - Implement fallback logic for workspace detection:
     - Use configured workspace path if available
     - Fall back to automatic detection using patterns from cursor-chat-database-research.md
     - Handle cross-platform differences (Windows, macOS, Linux)

5. **Data Transformation**:
   - Transform raw SQLite data into the expected ChatHistory structure
   - Ensure compatibility with existing code that consumes the ChatHistory type
   - Maintain the existing return type structure to avoid breaking changes

# Test Strategy:
To verify the correct refactoring of the chat collection functionality:

1. **Verify Existing Tests**:
   - Confirm that all existing tests continue to pass with the refactored implementation
   - Ensure no regressions are introduced in the journal workflow
   - Verify that the function maintains its expected behavior from the caller's perspective

2. **Unit Tests**:
   - Create test cases for the refactored collect_chat_history function:
     - Test with valid workspace path and existing database
     - Test with invalid workspace path
     - Test with valid path but missing database
     - Test with corrupted database
     - Test with empty database (no chats)
     - Test with various max_messages_back values

3. **Integration Tests**:
   - Test the integration with the ChatBoundaryDetector:
     - Verify that conversations are properly segmented
     - Verify that topic changes are correctly identified
     - Test with different boundary detection configurations

4. **Cross-Platform Testing**:
   - Test on Windows, macOS, and Linux to ensure workspace detection works correctly
   - Verify database path resolution on each platform
   - Test with different user permission scenarios

5. **Manual Verification**:
   - Run the function against a known Cursor chat database
   - Compare the output with expected chat history
   - Verify that all messages are correctly extracted
   - Check that timestamps and user information are preserved

6. **Error Handling Verification**:
   - Deliberately introduce errors to test error handling:
     - Remove database file permissions
     - Modify database schema
     - Simulate database corruption
     - Test with network drives or unusual file paths

7. **Performance Testing**:
   - Test with large chat histories to ensure performance
   - Measure execution time and memory usage
   - Verify that the function handles large datasets efficiently
   - Test the impact of different max_messages_back values
