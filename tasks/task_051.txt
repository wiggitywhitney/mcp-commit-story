# Task ID: 51
# Title: Implement Journal/Capture-Context MCP Tool
# Status: in-progress
# Dependencies: None
# Priority: high
# Description: Create an MCP tool that allows users to manually capture context that will be included in future journal entries, enabling developers to add relevant information that might not be captured automatically.
# Details:
Implement the journal/capture-context MCP tool with the following components:

## Research & Design Results (Updated 2025-07-01)

Based on design conversations with the user, this tool will serve as a knowledge capture mechanism where:

1. **User Trigger**: Users manually invoke via Cursor chat
2. **MCP Tool Execution**: Tool captures AI's current knowledge state using an optimized prompt
3. **Chronological Appending**: Captured knowledge gets appended to today's journal file
4. **Future Context**: Later git commits trigger fresh AI which sees this captured knowledge in today's journal context
5. **Richer Journal Entries**: Fresh AI synthesizes better entries because it has access to previous AI's accumulated insights

### Approved Prompt Design
The backend prompt should be:
"Provide a comprehensive knowledge capture of your current understanding of this project, recent development insights, and key context that would help a fresh AI understand where we are and how we got here. Focus on context that would be valuable for future journal entries."

### Tool Implementation Strategy
- Single comprehensive approach (no complexity for users to think about different capture types)
- When AI receives a knowledge capture request it naturally covers:
  - Project state and architecture understanding
  - Recent development insights and patterns discovered
  - Decision context and rationale
  - Technical understanding gained during the session
  - Development patterns and approaches observed

This creates a continuous knowledge transfer mechanism that enriches the journal generation process.

1. **MCP Server Handler**:
```python
@trace_mcp_operation
def handle_journal_capture_context(params, config):
    """
    Handle requests to capture manual context for journal entries.
    
    Args:
        params (dict): Parameters including:
            - text (str): The context text to capture
            - tags (list, optional): List of tags to associate with the context
        config (dict): Configuration dictionary
        
    Returns:
        dict: Response with status and captured context details
    """
    try:
        # Extract parameters
        text = params.get("text")
        if not text:
            return {"status": "error", "message": "No context text provided"}
            
        tags = params.get("tags", ["manual-context"])
        if "manual-context" not in tags:
            tags.append("manual-context")
            
        # Format the captured context
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        formatted_context = f"\n\n## Manual Context Capture ({timestamp})\n\n{text}\n\n"
        formatted_context += f"Tags: {', '.join(tags)}\n"
        
        # Determine today's journal file path
        journal_path = Path(config["journal"]["path"])
        today = datetime.now().strftime("%Y-%m-%d")
        journal_file = journal_path / f"{today}.md"
        
        # Create directory if it doesn't exist
        journal_path.mkdir(parents=True, exist_ok=True)
        
        # Append context to today's journal file
        with open(journal_file, "a+") as f:
            f.write(formatted_context)
            
        return {
            "status": "success",
            "message": "Context captured successfully",
            "file": str(journal_file),
            "timestamp": timestamp,
            "tags": tags
        }
    except Exception as e:
        return {"status": "error", "message": f"Failed to capture context: {str(e)}"}
```

2. **Register the Handler in MCP Server**:
Add the new handler to the server's tool registry in `src/mcp_commit_story/server.py`:
```python
def register_tools():
    # ... existing tool registrations ...
    
    # Register the capture-context tool
    register_tool(
        "journal/capture-context",
        "Capture manual context for journal entries",
        handle_journal_capture_context,
        [
            {"name": "text", "type": "string", "description": "Context text to capture"},
            {"name": "tags", "type": "array", "description": "Optional tags for the context", "required": False}
        ]
    )
```

3. **CLI Command Implementation**:
Add a CLI command for capturing context in `src/mcp_commit_story/cli.py`:
```python
@cli.command()
@click.argument("text")
@click.option("--tags", "-t", multiple=True, help="Tags to associate with the context")
def capture(text, tags):
    """Capture manual context for journal entries."""
    response = send_mcp_request("journal/capture-context", {
        "text": text,
        "tags": list(tags) if tags else ["manual-context"]
    })
    
    if response.get("status") == "success":
        click.echo(f"Context captured successfully in {response.get('file')}")
    else:
        click.echo(f"Error: {response.get('message')}", err=True)
```

4. **Update Standalone Journal Generator**:
Modify the standalone journal generator (from Task 50) to include captured context when generating entries:
```python
def collect_recent_manual_context(days=1):
    """
    Collect manual context captured in recent journal entries.
    
    Args:
        days (int): Number of days to look back for context
        
    Returns:
        str: Concatenated manual context entries
    """
    journal_path = Path(config["journal"]["path"])
    context_entries = []
    
    # Get dates for the lookback period
    today = datetime.now().date()
    date_range = [today - timedelta(days=i) for i in range(days)]
    
    # Check each date's journal file for manual context
    for date in date_range:
        date_str = date.strftime("%Y-%m-%d")
        journal_file = journal_path / f"{date_str}.md"
        
        if journal_file.exists():
            with open(journal_file, "r") as f:
                content = f.read()
                
            # Extract manual context sections using regex
            manual_contexts = re.findall(r"## Manual Context Capture \(.*?\)(.*?)(?=\n## |\Z)", 
                                        content, re.DOTALL)
            
            if manual_contexts:
                for context in manual_contexts:
                    context_entries.append(context.strip())
    
    return "\n\n".join(context_entries)
```

5. **Integration with Journal Generation**:
Update the journal generation function to include the captured context:
```python
def generate_journal_entry(commit_info, config):
    """Generate a journal entry for a commit"""
    # ... existing code ...
    
    # Add manual context if available
    recent_context = collect_recent_manual_context()
    if recent_context:
        prompt_parts.append("\nRecently captured manual context:")
        prompt_parts.append(recent_context)
    
    # ... continue with existing generation code ...
```

# Test Strategy:
To verify the correct implementation of the journal/capture-context MCP tool:

1. **Unit Tests**:
   - Create unit tests for the `handle_journal_capture_context` function:
     ```python
     def test_handle_journal_capture_context():
         # Test with valid parameters
         result = handle_journal_capture_context({"text": "Test context"}, test_config)
         assert result["status"] == "success"
         assert "file" in result
         
         # Test with empty text
         result = handle_journal_capture_context({"text": ""}, test_config)
         assert result["status"] == "error"
         
         # Test with custom tags
         result = handle_journal_capture_context({"text": "Test with tags", "tags": ["important", "meeting"]}, test_config)
         assert "manual-context" in result["tags"]
         assert "important" in result["tags"]
     ```

2. **Integration Tests**:
   - Test the MCP server handler registration:
     ```python
     def test_capture_context_tool_registration():
         tools = get_registered_tools()
         assert "journal/capture-context" in tools
     ```
   
   - Test the CLI command:
     ```python
     def test_capture_cli_command():
         runner = CliRunner()
         result = runner.invoke(cli, ["capture", "Test context from CLI"])
         assert "Context captured successfully" in result.output
         
         # Test with tags
         result = runner.invoke(cli, ["capture", "Test with tags", "-t", "important", "-t", "meeting"])
         assert "Context captured successfully" in result.output
     ```

3. **Manual Testing**:
   - Execute the following test scenarios:
     1. Capture context with the CLI command: `mcp-commit-story capture "This is important context for today's work"`
     2. Verify the context is appended to today's journal file
     3. Capture context with tags: `mcp-commit-story capture "Meeting notes" -t meeting -t important`
     4. Verify the context with tags is correctly formatted in the journal file
     5. Generate a journal entry after capturing context and verify the context is included
     6. Test the MCP API directly: `curl -X POST http://localhost:5000/api/tool/journal/capture-context -d '{"text":"API test context"}'`

4. **File System Verification**:
   - Check that the journal directory is created if it doesn't exist
   - Verify that context is properly appended to existing journal files
   - Ensure the timestamp and tags are correctly formatted

5. **Standalone Generator Integration Test**:
   - Capture context using the tool
   - Run the standalone journal generator
   - Verify that the generated journal entry includes the captured context
   - Test with multiple days of context to ensure the lookback period works correctly

# Subtasks:
## 1. Implement MCP Server Handler for capture-context [pending]
### Dependencies: None
### Description: Create the core handler function that processes capture-context requests and appends to journal files. Also fix the reflection format to include the separator.
### Details:
Implementation Plan:

WRITE TESTS FIRST

Create tests/unit/test_capture_context_handler.py
Test handle_journal_capture_context() function
Test cases:

Valid text parameter returns success
Empty text parameter returns error
Context is properly formatted with separator and timestamp
Journal directory is created if missing
File path is returned in response
Exception handling returns proper error format


Create/update tests/unit/test_reflection_format.py
Test that format_reflection() includes separator:

Verify output starts with \n\n____\n\n###
Test timestamp formatting


RUN TESTS - VERIFY THEY FAIL


IMPLEMENT FUNCTIONALITY

Fix reflection format in reflection_core.py:
```python
def format_reflection(reflection_text: str) -> str:
    timestamp = datetime.now().strftime("%I:%M %p").lstrip('0')
    return f"\n\n____\n\n### {timestamp} — Reflection\n\n{reflection_text}"
```

Create handle_journal_capture_context() in src/mcp_commit_story/journal_handlers.py
Format should match:
```python
def format_ai_knowledge_capture(knowledge_text: str) -> str:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"\n\n____\n\n## AI Knowledge Capture ({timestamp})\n\n{knowledge_text}"
```

Extract and validate parameters
Determine today's journal file path using config
Use append_to_journal_file() for consistency
Return standardized response
RUN TESTS - VERIFY THEY PASS


DOCUMENT AND COMPLETE

Add documentation in code docstrings
Document the separator fix for reflections
Do not reference tasks
Write for the reader: Explain what the handler does
Run the entire test suite
MARK COMPLETE


This ensures both reflections and AI knowledge captures have consistent formatting with proper separators.
<info added on 2025-07-07T21:18:19.476Z>
UPDATED IMPLEMENTATION PLAN:

WRITE TESTS FIRST

Create tests/unit/test_capture_context_handler.py
Test handle_journal_capture_context() function
Test cases:
- Valid text parameter returns success
- Empty text parameter returns error
- Context is properly formatted with unified header format: `### 2:30 PM — AI Knowledge Capture`
- Uses same timestamp format as journal entries: `%I:%M %p` (like "2:30 PM")
- Journal directory is created if missing
- File path is returned in response
- Exception handling returns proper error format

Create/update tests/unit/test_reflection_format.py
Test that format_reflection() includes separator:
- Verify output starts with \n\n____\n\n###
- Test timestamp formatting matches unified format

RUN TESTS - VERIFY THEY FAIL

IMPLEMENT FUNCTIONALITY

Fix reflection format in reflection_core.py:
```python
def format_reflection(reflection_text: str) -> str:
    timestamp = datetime.now().strftime("%I:%M %p").lstrip('0')
    return f"\n\n____\n\n### {timestamp} — Reflection\n\n{reflection_text}"
```

Create handle_journal_capture_context() in src/mcp_commit_story/journal_handlers.py
Format with unified header format:
```python
def format_ai_knowledge_capture(knowledge_text: str) -> str:
    timestamp = datetime.now().strftime("%I:%M %p").lstrip('0')
    return f"\n\n____\n\n### {timestamp} — AI Knowledge Capture\n\n{knowledge_text}"
```

- Extract and validate parameters
- Determine today's journal file path using config
- Use append_to_journal_file() for consistency
- Return standardized response

RUN TESTS - VERIFY THEY PASS

DOCUMENT AND COMPLETE
- Add documentation in code docstrings
- Document the unified header format (### timestamp — type)
- Document the separator fix for reflections
- Do not reference tasks
- Write for the reader: Explain what the handler does
- Run the entire test suite
- MARK COMPLETE

This ensures journal entries, reflections, and AI knowledge captures all use the same header format and timestamp style for perfect consistency.
</info added on 2025-07-07T21:18:19.476Z>

## 2. Register capture-context Tool in MCP Server [pending]
### Dependencies: None
### Description: Add the tool to the server's registry with proper metadata and parameter definitions following existing patterns.
### Details:
Implementation Plan:

WRITE TESTS FIRST

Create tests/unit/test_capture_context_mcp_handler.py
Test MCP handler function in server.py
Test cases:
- Valid text parameter returns success with status, file_path
- Empty text parameter returns error
- Handler calls journal_handlers.handle_journal_capture_context correctly
- Handler follows async pattern and error handling
- Response matches CaptureContextResponse TypedDict format
- Exception handling returns appropriate error format with handle_mcp_error decorator

RUN TESTS - VERIFY THEY FAIL

IMPLEMENT FUNCTIONALITY

Update src/mcp_commit_story/server.py:

Add TypedDict definitions near other request/response types:
```python
# Request/response types for journal/capture-context
class CaptureContextRequest(TypedDict):
    text: str  # AI-generated project knowledge to capture

class CaptureContextResponse(TypedDict):
    status: str
    file_path: str
    error: Optional[str]
```

Import the handler implementation:
```python
from mcp_commit_story.journal_handlers import handle_journal_capture_context
```

In register_tools() function, add after journal_add_reflection:
```python
@server.tool()
@trace_mcp_operation("journal_capture_context")
async def journal_capture_context(request: CaptureContextRequest) -> CaptureContextResponse:
    """Capture AI's current project knowledge to provide context for future journal entries."""
    return await handle_journal_capture_context_mcp(request)
```

Add MCP handler function following existing pattern:
```python
@handle_mcp_error
@trace_mcp_operation("capture_context.handle_mcp", attributes={
    "operation_type": "mcp_handler", 
    "content_type": "ai_context"
})
async def handle_journal_capture_context_mcp(request: CaptureContextRequest) -> CaptureContextResponse:
    """MCP handler for capturing AI context - lightweight delegation to implementation."""
    if not request.get("text"):
        raise MCPError("Missing required field: text")
    
    # Call the actual implementation (sync function)
    result = handle_journal_capture_context(request["text"])
    
    return {
        "status": result["status"],
        "file_path": result.get("file_path", ""),
        "error": result.get("error")
    }
```

RUN TESTS - VERIFY THEY PASS

DOCUMENT AND COMPLETE
- Ensure handler docstring is clear: "Capture AI's current project knowledge to provide context for future journal entries"
- Follow existing error handling and telemetry patterns
- Use same decorator pattern (@handle_mcp_error, @trace_mcp_operation)
- Do not reference tasks or implementation history
- Run the entire test suite
- MARK COMPLETE

Design Decisions:
- Tool name: journal_capture_context (snake_case, "capture" distinguishes from "add")
- NO date parameter - always writes to today's journal (current AI session context)
- Single text parameter for AI-generated knowledge
- Lightweight MCP handler delegates to journal_handlers implementation
- Follows exact patterns from existing journal tools
<info added on 2025-07-08T01:13:37.628Z>
**Tool Name vs Function Name Clarification:**

In FastMCP, the tool name exposed to clients follows the pattern with slashes and hyphens, while the Python function uses snake_case:

Update the tool registration in server.py to:
```python
@server.tool("journal/capture-context")
@trace_mcp_operation("journal_capture_context")
async def journal_capture_context(request: CaptureContextRequest) -> CaptureContextResponse:
    """Capture AI's current project knowledge to provide context for future journal entries."""
    return await handle_journal_capture_context_mcp(request)
```

Add to test cases:
- Verify tool is registered with name "journal/capture-context" in the tool registry
- Function name remains journal_capture_context in Python code
- Trace operation uses "journal_capture_context" for consistency

This follows the established pattern where external tool names use slash/hyphen notation while internal function names use snake_case.
</info added on 2025-07-08T01:13:37.628Z>
<info added on 2025-07-08T01:14:33.813Z>
**Tool Name Correction:**

After reviewing the actual codebase, I need to correct the tool naming pattern. All existing tools use the function name as the tool name (both in snake_case):

- Tool name: `journal_capture_context` (same as function name)
- Function name: `journal_capture_context` (snake_case)
- Trace operation name: `journal_capture_context` (same as function name)

The correct tool registration in server.py should be:
```python
@server.tool()
@trace_mcp_operation("journal_capture_context")
async def journal_capture_context(request: CaptureContextRequest) -> CaptureContextResponse:
    """Capture AI's current project knowledge to provide context for future journal entries."""
    return await handle_journal_capture_context_mcp(request)
```

Updated test cases:
- Tool appears in registry with name "journal_capture_context" (matching function name)
- Function name is journal_capture_context
- Trace operation uses "journal_capture_context"
- Follows exact same pattern as existing tools

This maintains consistency with the established codebase pattern where tool names and function names are identical.
</info added on 2025-07-08T01:14:33.813Z>

