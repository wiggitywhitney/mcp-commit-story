# Task ID: 71
# Title: Implement Lightweight Tagging and Narrative Threading for Journal Summaries
# Status: pending
# Dependencies: 53
# Priority: medium
# Description: Enhance journal generation and summaries to surface recurring themes and connect emotional reactions to technical decisions through lightweight tagging and narrative threading to support conference talk preparation and retrospectives.
# Details:
## Implementation Details

### 1. Tagging System Implementation
- Implement a lightweight tagging system with predefined tags:
  - `#AI-misstep`
  - `#breakthrough`
  - `#pivot`
  - `#recurring-issue`

```python
def add_tags_to_journal_content(content, context):
    """
    Analyze journal content and add relevant tags based on context.
    
    Args:
        content (str): The journal entry content
        context (dict): Context information including commit data, previous entries
        
    Returns:
        str: Journal content with embedded tags
    """
    # Analyze content for tag-worthy patterns
    tags = []
    
    # Detect breakthroughs (significant positive progress)
    if re.search(r'(succeed|breakthrough|finally|solved|eureka)', content, re.I):
        tags.append('#breakthrough')
    
    # Detect AI-related issues
    if re.search(r'(AI|LLM|model).{0,30}(wrong|incorrect|hallucination|error)', content, re.I):
        tags.append('#AI-misstep')
    
    # Detect pivots in approach
    if re.search(r'(change|pivot|shift|switch).{0,30}(approach|direction|strategy)', content, re.I):
        tags.append('#pivot')
    
    # Detect recurring issues
    if re.search(r'(again|recurring|still|another|same).{0,30}(issue|problem|error)', content, re.I):
        tags.append('#recurring-issue')
    
    # Add tags to content (either as metadata or embedded)
    if tags:
        tag_section = "\n\n**Tags**: " + " ".join(tags)
        content += tag_section
        
    return content
```

### 2. Emotion-Tech Pairing Implementation
- Modify the journal generation prompts to explicitly connect emotional reactions with technical decisions:

```python
def enhance_journal_prompt_with_emotion_tech_pairing(prompt_template):
    """
    Enhance the journal generation prompt to emphasize emotion-tech pairing.
    
    Args:
        prompt_template (str): The original prompt template
        
    Returns:
        str: Enhanced prompt template
    """
    emotion_tech_guidance = """
    When describing technical decisions, include your emotional reaction and reflection:
    - How did you feel about this approach?
    - What intuitions guided your technical choices?
    - Connect your emotional state to the technical decisions made
    - Describe how your feelings about the code evolved during implementation
    """
    
    # Insert the guidance at an appropriate point in the template
    enhanced_prompt = prompt_template.replace(
        "# Additional Instructions:",
        f"# Additional Instructions:\n{emotion_tech_guidance}"
    )
    
    return enhanced_prompt
```

### 3. AI-as-Character Implementation
- Modify prompts to treat AI collaboration as part of the narrative:

```python
def implement_ai_as_character(prompt_template):
    """
    Enhance prompts to treat AI as a character in the development narrative.
    
    Args:
        prompt_template (str): The original prompt template
        
    Returns:
        str: Enhanced prompt template
    """
    ai_character_guidance = """
    Treat AI tools and assistants as characters in your development story:
    - Give the AI a consistent personality across entries
    - Describe interactions with AI as conversations with a teammate
    - Include how the AI's suggestions influenced your thinking
    - Note when the AI was particularly helpful or frustrating
    """
    
    enhanced_prompt = prompt_template.replace(
        "# Additional Instructions:",
        f"# Additional Instructions:\n{ai_character_guidance}"
    )
    
    return enhanced_prompt
```

### 4. Recurring Theme Detection in Summaries
- Enhance the summary generation to detect and highlight recurring themes:

```python
def detect_recurring_themes(journal_entries, time_period="week"):
    """
    Analyze journal entries to detect recurring themes based on tags and content.
    
    Args:
        journal_entries (list): List of journal entry objects
        time_period (str): Time period for analysis ("week", "month", etc.)
        
    Returns:
        dict: Dictionary of recurring themes with examples and counts
    """
    # Extract all tags from entries
    all_tags = []
    for entry in journal_entries:
        entry_tags = re.findall(r'#(\w+(?:-\w+)*)', entry.content)
        all_tags.extend(entry_tags)
    
    # Count tag occurrences
    tag_counts = Counter(all_tags)
    
    # Define threshold for "recurring" (2+ instances)
    recurring_threshold = 2
    recurring_themes = {tag: count for tag, count in tag_counts.items() 
                       if count >= recurring_threshold}
    
    # Find examples for each recurring theme
    theme_examples = {}
    for theme in recurring_themes:
        examples = []
        for entry in journal_entries:
            if f"#{theme}" in entry.content:
                # Extract relevant paragraph containing the tag
                paragraphs = entry.content.split('\n\n')
                for para in paragraphs:
                    if f"#{theme}" in para:
                        examples.append({
                            'date': entry.date,
                            'excerpt': para[:200] + "..." if len(para) > 200 else para
                        })
                        break
        theme_examples[theme] = examples[:3]  # Limit to 3 examples
    
    return {
        'counts': recurring_themes,
        'examples': theme_examples
    }
```

### 5. Narrative-Focused Summary Generation
- Implement a narrative-focused summary generator that connects cause-and-effect patterns:

```python
def generate_narrative_summary(journal_entries, recurring_themes):
    """
    Generate a narrative-focused summary connecting cause-and-effect patterns.
    
    Args:
        journal_entries (list): List of journal entry objects
        recurring_themes (dict): Dictionary of recurring themes from detect_recurring_themes()
        
    Returns:
        str: Narrative summary connecting events across time
    """
    # Sort entries chronologically
    sorted_entries = sorted(journal_entries, key=lambda x: x.date)
    
    # Extract key events with their tags
    key_events = []
    for entry in sorted_entries:
        tags = re.findall(r'#(\w+(?:-\w+)*)', entry.content)
        if tags:
            key_events.append({
                'date': entry.date,
                'tags': tags,
                'content': entry.content
            })
    
    # Group events by theme
    theme_narratives = {}
    for theme, count in recurring_themes['counts'].items():
        theme_events = [event for event in key_events if theme in event['tags']]
        if theme_events:
            # Sort events chronologically
            theme_events.sort(key=lambda x: x['date'])
            theme_narratives[theme] = theme_events
    
    # Generate narrative summary
    summary = "# Narrative Summary\n\n"
    
    # Add overall arc
    summary += "## Development Journey Overview\n\n"
    summary += "This period was characterized by "
    if 'breakthrough' in recurring_themes['counts']:
        summary += f"{recurring_themes['counts']['breakthrough']} breakthroughs, "
    if 'AI-misstep' in recurring_themes['counts']:
        summary += f"{recurring_themes['counts']['AI-misstep']} AI challenges, "
    if 'pivot' in recurring_themes['counts']:
        summary += f"{recurring_themes['counts']['pivot']} strategic pivots, "
    if 'recurring-issue' in recurring_themes['counts']:
        summary += f"and {recurring_themes['counts']['recurring-issue']} recurring issues."
    summary += "\n\n"
    
    # Add theme-based narratives
    for theme, events in theme_narratives.items():
        summary += f"## {theme.replace('-', ' ').title()} Narrative\n\n"
        
        # Create a chronological story
        story = ""
        for i, event in enumerate(events):
            date_str = event['date'].strftime("%b %d")
            if i == 0:
                story += f"The first instance occurred on {date_str} when "
            elif i == len(events) - 1:
                story += f"Finally, on {date_str}, "
            else:
                story += f"Then on {date_str}, "
            
            # Extract relevant content
            paragraphs = event['content'].split('\n\n')
            relevant_para = ""
            for para in paragraphs:
                if f"#{theme}" in para:
                    relevant_para = para
                    break
            
            if not relevant_para:
                relevant_para = paragraphs[0]
            
            # Clean up the paragraph (remove tags, etc.)
            cleaned_para = re.sub(r'#\w+(?:-\w+)*', '', relevant_para).strip()
            story += cleaned_para + "\n\n"
        
        summary += story + "\n"
    
    # Add cause-effect connections
    summary += "## Cause and Effect Patterns\n\n"
    
    # Look for pivot events that follow recurring issues
    pivot_after_issues = []
    for pivot_event in key_events:
        if 'pivot' in pivot_event['tags']:
            # Find recurring issues before this pivot
            issue_events = [e for e in key_events 
                           if 'recurring-issue' in e['tags'] 
                           and e['date'] < pivot_event['date']]
            if issue_events:
                pivot_after_issues.append({
                    'pivot': pivot_event,
                    'issues': issue_events[-1]  # Most recent issue before pivot
                })
    
    # Add pivot narratives
    if pivot_after_issues:
        summary += "### Pivots Following Recurring Issues\n\n"
        for pair in pivot_after_issues:
            summary += f"After encountering recurring issues on {pair['issues']['date'].strftime('%b %d')}, "
            summary += f"the team pivoted on {pair['pivot']['date'].strftime('%b %d')}.\n\n"
    
    return summary
```

### 6. Integration with Existing Summary Generation
- Modify the existing summary generation in `src/mcp_commit_story/daily_summary.py` to incorporate the new tagging and narrative threading:

```python
def enhance_summary_generation(summary_generator):
    """
    Enhance the existing summary generator with tagging and narrative threading.
    
    Args:
        summary_generator: The existing summary generator function
        
    Returns:
        function: Enhanced summary generator
    """
    def enhanced_generator(*args, **kwargs):
        # Get original summary
        original_summary = summary_generator(*args, **kwargs)
        
        # Get journal entries for the period
        journal_entries = kwargs.get('journal_entries', [])
        if not journal_entries and 'date' in kwargs:
            # Load journal entries based on date
            journal_entries = load_journal_entries_for_period(kwargs['date'])
        
        # Detect recurring themes
        recurring_themes = detect_recurring_themes(journal_entries)
        
        # Generate narrative summary
        narrative_summary = generate_narrative_summary(journal_entries, recurring_themes)
        
        # Combine original and narrative summaries
        combined_summary = original_summary + "\n\n" + narrative_summary
        
        return combined_summary
    
    return enhanced_generator
```

### 7. Storage Strategy for Tags
- Store tags as both metadata and embedded content:
  - Embedded in content for human readability
  - Extract to metadata for efficient querying
  
```python
def extract_tags_to_metadata(journal_entry):
    """
    Extract tags from journal content to metadata for efficient querying.
    
    Args:
        journal_entry: Journal entry object
        
    Returns:
        dict: Updated metadata with tags
    """
    content = journal_entry.content
    tags = re.findall(r'#(\w+(?:-\w+)*)', content)
    
    # Update metadata
    metadata = journal_entry.metadata or {}
    metadata['tags'] = list(set(tags))  # Deduplicate tags
    
    return metadata
```

### 8. Configuration Options
- Add configuration options for tagging and narrative threading:

```python
# Example configuration additions
tagging_config = {
    "enabled": True,
    "store_as_metadata": True,
    "store_in_content": True,
    "custom_tags": [],  # Allow user-defined additional tags
    "recurring_threshold": 2,  # Number of occurrences to consider a theme recurring
    "time_period_for_themes": "week"  # week, month, etc.
}
```

# Test Strategy:
## Test Strategy

### 1. Unit Tests for Tagging System

```python
def test_add_tags_to_journal_content():
    """Test that appropriate tags are added to journal content"""
    # Test breakthrough detection
    breakthrough_content = "Today I finally solved the persistent caching issue that was blocking progress."
    tagged_content = add_tags_to_journal_content(breakthrough_content, {})
    assert "#breakthrough" in tagged_content
    
    # Test AI misstep detection
    ai_misstep_content = "The AI model gave incorrect suggestions for optimizing the database queries."
    tagged_content = add_tags_to_journal_content(ai_misstep_content, {})
    assert "#AI-misstep" in tagged_content
    
    # Test pivot detection
    pivot_content = "We decided to change our approach to authentication after reviewing security concerns."
    tagged_content = add_tags_to_journal_content(pivot_content, {})
    assert "#pivot" in tagged_content
    
    # Test recurring issue detection
    recurring_content = "We're still facing the same memory leak issue in the processing module."
    tagged_content = add_tags_to_journal_content(recurring_content, {})
    assert "#recurring-issue" in tagged_content
    
    # Test multiple tag detection
    complex_content = "After the AI gave incorrect suggestions again, we pivoted to a manual approach."
    tagged_content = add_tags_to_journal_content(complex_content, {})
    assert "#AI-misstep" in tagged_content
    assert "#pivot" in tagged_content
    assert "#recurring-issue" in tagged_content
```

### 2. Unit Tests for Emotion-Tech Pairing

```python
def test_enhance_journal_prompt_with_emotion_tech_pairing():
    """Test that emotion-tech pairing is correctly added to prompts"""
    original_prompt = "# Journal Entry\n\nWrite about today's work.\n\n# Additional Instructions:\nBe concise."
    enhanced_prompt = enhance_journal_prompt_with_emotion_tech_pairing(original_prompt)
    
    # Check that the emotion-tech guidance was added
    assert "emotional reaction" in enhanced_prompt
    assert "intuitions guided" in enhanced_prompt
    assert "feelings about the code" in enhanced_prompt
    
    # Check that original content is preserved
    assert "# Journal Entry" in enhanced_prompt
    assert "Write about today's work" in enhanced_prompt
    assert "Be concise" in enhanced_prompt
```

### 3. Unit Tests for AI-as-Character Implementation

```python
def test_implement_ai_as_character():
    """Test that AI-as-character guidance is correctly added to prompts"""
    original_prompt = "# Journal Entry\n\nWrite about today's work.\n\n# Additional Instructions:\nBe concise."
    enhanced_prompt = implement_ai_as_character(original_prompt)
    
    # Check that the AI-as-character guidance was added
    assert "AI tools and assistants as characters" in enhanced_prompt
    assert "consistent personality" in enhanced_prompt
    assert "conversations with a teammate" in enhanced_prompt
    
    # Check that original content is preserved
    assert "# Journal Entry" in enhanced_prompt
    assert "Write about today's work" in enhanced_prompt
    assert "Be concise" in enhanced_prompt
```

### 4. Unit Tests for Recurring Theme Detection

```python
def test_detect_recurring_themes():
    """Test that recurring themes are correctly detected"""
    # Create mock journal entries
    from datetime import datetime, timedelta
    
    class MockEntry:
        def __init__(self, date, content):
            self.date = date
            self.content = content
    
    today = datetime.now()
    entries = [
        MockEntry(today - timedelta(days=5), "Working on the API. #breakthrough"),
        MockEntry(today - timedelta(days=4), "The AI gave incorrect suggestions. #AI-misstep"),
        MockEntry(today - timedelta(days=3), "Still having issues with the API. #recurring-issue"),
        MockEntry(today - timedelta(days=2), "The AI hallucinated again. #AI-misstep"),
        MockEntry(today - timedelta(days=1), "Changed our approach to the API. #pivot")
    ]
    
    themes = detect_recurring_themes(entries)
    
    # Check that AI-misstep is detected as recurring (appears twice)
    assert 'AI-misstep' in themes['counts']
    assert themes['counts']['AI-misstep'] == 2
    
    # Check that examples are provided
    assert 'examples' in themes
    assert 'AI-misstep' in themes['examples']
    assert len(themes['examples']['AI-misstep']) == 2
```

### 5. Unit Tests for Narrative Summary Generation

```python
def test_generate_narrative_summary():
    """Test that narrative summaries correctly connect events"""
    # Create mock journal entries and themes
    from datetime import datetime, timedelta
    
    class MockEntry:
        def __init__(self, date, content):
            self.date = date
            self.content = content
    
    today = datetime.now()
    entries = [
        MockEntry(today - timedelta(days=5), "Working on the API. #breakthrough"),
        MockEntry(today - timedelta(days=4), "The AI gave incorrect suggestions. #AI-misstep"),
        MockEntry(today - timedelta(days=3), "Still having issues with the API. #recurring-issue"),
        MockEntry(today - timedelta(days=2), "The AI hallucinated again. #AI-misstep"),
        MockEntry(today - timedelta(days=1), "Changed our approach to the API. #pivot")
    ]
    
    recurring_themes = {
        'counts': {
            'AI-misstep': 2,
            'recurring-issue': 1,
            'breakthrough': 1,
            'pivot': 1
        },
        'examples': {
            'AI-misstep': [
                {'date': today - timedelta(days=4), 'excerpt': "The AI gave incorrect suggestions."},
                {'date': today - timedelta(days=2), 'excerpt': "The AI hallucinated again."}
            ]
        }
    }
    
    summary = generate_narrative_summary(entries, recurring_themes)
    
    # Check that the summary includes all expected sections
    assert "Development Journey Overview" in summary
    assert "AI-misstep Narrative" in summary
    assert "Cause and Effect Patterns" in summary
    
    # Check that the summary connects events chronologically
    assert "first instance" in summary
    assert today.strftime("%b") in summary  # Month abbreviation should be in the summary
```

### 6. Integration Tests for Enhanced Summary Generation

```python
def test_enhanced_summary_generation():
    """Test that the enhanced summary generator correctly integrates with existing code"""
    # Mock the original summary generator
    def mock_original_generator(*args, **kwargs):
        return "# Original Summary\n\nThis is the original summary content."
    
    # Create the enhanced generator
    enhanced_generator = enhance_summary_generation(mock_original_generator)
    
    # Create mock journal entries
    from datetime import datetime, timedelta
    
    class MockEntry:
        def __init__(self, date, content, metadata=None):
            self.date = date
            self.content = content
            self.metadata = metadata or {}
    
    today = datetime.now()
    entries = [
        MockEntry(today - timedelta(days=5), "Working on the API. #breakthrough"),
        MockEntry(today - timedelta(days=4), "The AI gave incorrect suggestions. #AI-misstep"),
        MockEntry(today - timedelta(days=3), "Still having issues with the API. #recurring-issue"),
        MockEntry(today - timedelta(days=2), "The AI hallucinated again. #AI-misstep"),
        MockEntry(today - timedelta(days=1), "Changed our approach to the API. #pivot")
    ]
    
    # Generate enhanced summary
    enhanced_summary = enhanced_generator(journal_entries=entries, date=today)
    
    # Check that the enhanced summary contains both original and narrative content
    assert "Original Summary" in enhanced_summary
    assert "Narrative Summary" in enhanced_summary
    assert "Development Journey Overview" in enhanced_summary
```

### 7. End-to-End Tests

```python
def test_end_to_end_tagging_and_narrative_threading():
    """Test the complete tagging and narrative threading workflow"""
    # This test should:
    # 1. Generate journal entries with tags
    # 2. Extract tags to metadata
    # 3. Generate a summary with narrative threading
    # 4. Verify the summary contains the expected narrative elements
    
    # Set up test repository and configuration
    test_repo = setup_test_repository()
    test_config = load_test_configuration()
    
    # Generate journal entries with tags
    for i in range(5):
        generate_test_journal_entry(test_repo, test_config, i)
    
    # Generate summary
    summary = generate_summary(test_repo, test_config)
    
    # Verify summary contains narrative elements
    assert "Development Journey Overview" in summary
    assert "Cause and Effect Patterns" in summary
    
    # Verify tags were correctly applied and used
    assert re.search(r'#\w+(?:-\w+)*', summary)
```

### 8. Configuration Tests

```python
def test_tagging_configuration():
    """Test that tagging configuration options work correctly"""
    # Test with tagging disabled
    config = {"tagging": {"enabled": False}}
    content = "Today I finally solved the persistent caching issue."
    tagged_content = add_tags_to_journal_content(content, {}, config)
    assert "#breakthrough" not in tagged_content
    
    # Test with custom tags
    config = {
        "tagging": {
            "enabled": True,
            "custom_tags": [
                {"pattern": r"refactor", "tag": "#code-cleanup"}
            ]
        }
    }
    content = "Spent the day refactoring the authentication module."
    tagged_content = add_tags_to_journal_content(content, {}, config)
    assert "#code-cleanup" in tagged_content
    
    # Test metadata-only storage
    config = {
        "tagging": {
            "enabled": True,
            "store_in_content": False,
            "store_as_metadata": True
        }
    }
    content = "Today I finally solved the persistent caching issue."
    entry = MockEntry(datetime.now(), content)
    tagged_entry = process_journal_entry_tags(entry, config)
    assert "#breakthrough" not in tagged_entry.content
    assert "breakthrough" in tagged_entry.metadata.get("tags", [])
```
