# Task ID: 49
# Title: Implement Git-Driven Chat Parsing
# Status: pending
# Dependencies: 48
# Priority: high
# Description: Add a function that intelligently filters chat history based on git diff content to find only relevant discussions related to code changes, and modify the existing collect_chat_history() to optionally use this filter.
# Details:
This task extends the existing chat collection system with a sophisticated filtering capability that uses git diff information to identify relevant chat segments:

1. **Extract Keywords from Git Diffs**:
```python
def extract_keywords_from_diff(diff_content):
    """
    Extract meaningful keywords, function names, and concepts from git diff content.
    
    Args:
        diff_content (str): The raw git diff content
        
    Returns:
        list: Extracted keywords, function names, and concepts
    """
    keywords = []
    
    # Extract function/method names (lines starting with + or - and containing def or function)
    function_pattern = r'[+-].*(?:def|function)\s+(\w+)'
    functions = re.findall(function_pattern, diff_content)
    keywords.extend(functions)
    
    # Extract class names
    class_pattern = r'[+-].*class\s+(\w+)'
    classes = re.findall(class_pattern, diff_content)
    keywords.extend(classes)
    
    # Extract variable names with meaningful context
    var_pattern = r'[+-].*(\w+)\s*='
    variables = re.findall(var_pattern, diff_content)
    keywords.extend([v for v in variables if len(v) > 3])  # Filter out short variable names
    
    # Extract file paths and names
    file_pattern = r'(?:---|\+\+\+)\s+(?:a/|b/)?(.+)'
    files = re.findall(file_pattern, diff_content)
    keywords.extend([os.path.basename(f) for f in files])
    
    # Remove duplicates and common programming keywords
    common_words = {'self', 'None', 'True', 'False', 'return', 'import', 'from', 'as'}
    keywords = [k for k in keywords if k not in common_words]
    
    return list(set(keywords))
```

2. **Score Chat Relevance**:
```python
def score_chat_relevance(chat_message, keywords, threshold=0.3):
    """
    Score the relevance of a chat message based on extracted keywords.
    
    Args:
        chat_message (dict): The chat message to score
        keywords (list): Keywords extracted from git diff
        threshold (float): Minimum score to consider relevant
        
    Returns:
        float: Relevance score between 0 and 1
    """
    if not keywords or not chat_message.get('content'):
        return 0.0
    
    content = chat_message['content'].lower()
    
    # Basic keyword matching
    direct_matches = sum(1 for kw in keywords if kw.lower() in content)
    
    # Use NLP techniques for semantic matching
    # This could be enhanced with embeddings or more sophisticated NLP
    words = re.findall(r'\w+', content)
    word_matches = sum(1 for kw in keywords for w in words 
                      if (kw.lower() in w.lower() or w.lower() in kw.lower()) 
                      and len(w) > 3)
    
    # Calculate final score
    total_keywords = len(keywords)
    if total_keywords == 0:
        return 0.0
        
    score = (direct_matches * 0.7 + word_matches * 0.3) / total_keywords
    
    return score if score >= threshold else 0.0
```

3. **Add New Filter Function to context_collection.py**:
```python
@trace_mcp_operation
def filter_chat_by_git_relevance(chat_history, diff_content, min_score=0.3, context_window=2):
    """
    Filter chat history based on git diff content to find relevant discussions.
    
    Args:
        chat_history (list): Complete chat history from collect_chat_history()
        diff_content (str): Git diff content
        min_score (float): Minimum relevance score threshold
        context_window (int): Number of messages to include before/after relevant ones
        
    Returns:
        list: Filtered chat segments relevant to the code changes
    """
    if not chat_history or not diff_content:
        return chat_history  # Return original if no filtering possible
    
    # Extract keywords from diff
    keywords = extract_keywords_from_diff(diff_content)
    
    # Score each message
    scored_messages = []
    for i, message in enumerate(chat_history):
        score = score_chat_relevance(message, keywords, min_score)
        scored_messages.append((i, message, score))
    
    # Identify relevant message clusters
    relevant_indices = set()
    for i, message, score in scored_messages:
        if score >= min_score:
            # Add the message and its context window
            for j in range(max(0, i - context_window), min(len(chat_history), i + context_window + 1)):
                relevant_indices.add(j)
    
    # Create continuous segments
    if not relevant_indices:
        return []  # No relevant messages found
        
    relevant_indices = sorted(relevant_indices)
    segments = []
    current_segment = []
    
    for i in range(len(chat_history)):
        if i in relevant_indices:
            current_segment.append(chat_history[i])
        elif current_segment:
            segments.append(current_segment)
            current_segment = []
    
    if current_segment:
        segments.append(current_segment)
    
    return segments
```

4. **Modify Existing collect_chat_history Function**:
```python
@trace_mcp_operation
def collect_chat_history(commit_hash=None, config=None, filter_by_git=False, file_path=None):
    """
    Collect chat history, optionally filtered by git relevance.
    
    Args:
        commit_hash (str): Optional commit hash for context
        config (dict): Configuration options
        filter_by_git (bool): Whether to filter chat by git relevance
        file_path (str): Optional specific file to focus on for filtering
        
    Returns:
        list: Chat history, potentially filtered by git relevance
    """
    # Original chat collection logic remains unchanged
    chat_history = [...existing implementation...]  
    
    # Apply git-based filtering if requested
    if filter_by_git:
        # Get git diff content using existing collect_git_context patterns
        if commit_hash:
            diff_content = get_git_diff(commit_hash, file_path)
        else:
            diff_content = get_uncommitted_changes(file_path)
        
        # Apply filtering with configurable parameters
        min_score = config.get('min_relevance_score', 0.3) if config else 0.3
        context_window = config.get('context_window', 2) if config else 2
        
        return filter_chat_by_git_relevance(chat_history, diff_content, min_score, context_window)
    
    # Return unfiltered chat history if filtering not requested
    return chat_history
```

The implementation should:
- Preserve backward compatibility by making filtering optional
- Integrate with existing git context collection patterns
- Handle edge cases such as empty git diffs or chat history
- Support configurable relevance thresholds and context windows
- Include proper error handling for git command failures
- Be optimized for performance with large chat histories

# Test Strategy:
To verify the correct implementation of the Git-Driven Chat Parsing functionality:

1. **Unit Tests for Keyword Extraction**:
   - Create test cases with sample git diffs containing various code constructs (functions, classes, variables)
   - Verify that the `extract_keywords_from_diff` function correctly identifies and extracts:
     - Function names (both additions and deletions)
     - Class names
     - Meaningful variable names
     - File paths and names
   - Test with empty diffs, large diffs, and diffs with special characters

2. **Unit Tests for Relevance Scoring**:
   - Create test cases with predefined keywords and various chat messages
   - Verify that `score_chat_relevance` correctly scores messages:
     - High scores for messages containing exact keyword matches
     - Moderate scores for messages with partial or semantic matches
     - Zero scores for completely irrelevant messages
   - Test edge cases: empty keywords, empty messages, very long messages

3. **Integration Tests for Filtering Logic**:
   - Create mock chat history and git diff content
   - Verify that `filter_chat_by_git_relevance` correctly:
     - Identifies relevant messages based on scoring
     - Includes appropriate context window messages
     - Creates continuous segments when relevant messages are close
     - Returns empty list for irrelevant chat history
     - Returns original chat history when diff content is empty

4. **Backward Compatibility Tests**:
   - Verify that `collect_chat_history` works exactly as before when `filter_by_git=False`
   - Ensure no regression in existing functionality
   - Test with various combinations of parameters to ensure all paths work correctly

5. **End-to-End Tests**:
   - Test the modified `collect_chat_history` function with:
     - `filter_by_git=True` and various other parameters
     - Real commit hashes from the project repository
     - Different configuration options (min_score, context_window)
     - Various file paths to filter specific changes
   - Verify that the returned chat segments are actually relevant to the code changes

6. **Performance Testing**:
   - Measure execution time with large chat histories (1000+ messages)
   - Compare performance with and without filtering
   - Ensure memory usage remains reasonable with large inputs
   - Verify that the implementation scales linearly with input size

7. **Manual Verification**:
   - Perform manual review of filtered results for a set of real commits
   - Compare the filtered chat segments with the complete history to verify relevance
   - Adjust relevance thresholds based on manual verification results

8. **Error Handling Tests**:
   - Test with invalid commit hashes
   - Test with non-existent file paths
   - Verify proper error messages and graceful failure modes
   - Ensure the system degrades gracefully when filtering cannot be applied

9. **Configuration Tests**:
   - Verify that different configuration values properly affect the filtering behavior
   - Test extreme configuration values (very high/low thresholds, large context windows)

Document all test results and any adjustments made to the implementation based on test findings.
