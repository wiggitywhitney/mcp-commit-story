# Task ID: 50
# Title: Create Standalone Journal Generator
# Status: pending
# Dependencies: None
# Priority: high
# Description: Refactor the existing git_hook_worker.py to call journal_workflow.generate_journal_entry() directly instead of creating signals, enabling journal generation to run from git hooks without requiring signals or MCP server.
# Details:
This task refactors the existing git hook worker to enable standalone journal generation that operates independently of the MCP server architecture:

1. **Refactor git_hook_worker.py to Call Journal Generation Directly**:
```python
# Current implementation (to be refactored):
def process_git_hook(hook_type):
    """Process a git hook event by creating appropriate signals"""
    try:
        git_context = collect_git_context()
        # Create signal for journal generation
        create_tool_signal('journal_generation', {
            'git_context': git_context,
            'hook_type': hook_type
        })
        return True
    except Exception as e:
        log_error(f"Git hook processing failed: {str(e)}")
        return False

# Refactored implementation:
def process_git_hook(hook_type):
    """Process a git hook event by directly generating journal entries"""
    try:
        git_context = collect_git_context()
        
        # Import journal workflow and call directly instead of creating a signal
        from journal_workflow import generate_journal_entry
        
        # Call journal generation directly with git context
        success = generate_journal_entry(git_context=git_context, hook_type=hook_type)
        
        # Log telemetry for the direct call
        log_telemetry('git_hook_journal_generation', {
            'success': success,
            'hook_type': hook_type,
            'commit_hash': git_context.get('commit_hash', 'unknown')
        })
        
        return success
    except Exception as e:
        log_error(f"Git hook processing failed: {str(e)}")
        return False
```

2. **Update Import Statements**:
```python
# Add these imports at the top of git_hook_worker.py
from journal_workflow import generate_journal_entry
from context_collection import collect_git_context
from logging_utils import log_error, log_telemetry
```

3. **Ensure Error Handling is Preserved**:
```python
# Make sure all existing error handling is maintained
def safe_journal_generation(git_context, hook_type):
    """Safely generate journal entries with proper error handling"""
    try:
        from journal_workflow import generate_journal_entry
        return generate_journal_entry(git_context=git_context, hook_type=hook_type)
    except ImportError as e:
        log_error(f"Failed to import journal_workflow: {str(e)}")
        return False
    except Exception as e:
        log_error(f"Journal generation failed: {str(e)}")
        return False
```

4. **Update CLI Command Handler**:
```python
def handle_cli_commands():
    """Handle CLI commands for git hook management"""
    parser = argparse.ArgumentParser(description='Git hook management and journal generation')
    parser.add_argument('--install-hooks', action='store_true', help='Install git hooks for automatic journal generation')
    parser.add_argument('--generate-now', action='store_true', help='Generate journal entry immediately')
    
    args = parser.parse_args()
    
    if args.install_hooks:
        success = install_git_hooks()
        print(f"Git hooks installation {'successful' if success else 'failed'}")
    
    if args.generate_now:
        git_context = collect_git_context()
        from journal_workflow import generate_journal_entry
        success = generate_journal_entry(git_context=git_context, hook_type='manual')
        print(f"Journal generation {'successful' if success else 'failed'}")
        
    if not args.install_hooks and not args.generate_now:
        parser.print_help()
```

5. **Update Post-Commit Hook Template**:
```python
def get_hook_template(hook_type):
    """Get the template for a specific git hook type"""
    if hook_type == 'post-commit':
        return """#!/bin/sh
# Auto-generated journal hook
python -m git_hook_worker --hook-type=post-commit
"""
    # Other hook templates...
    return """"""

# Update the hook handler to support direct execution
def main():
    """Main entry point for git hook worker"""
    parser = argparse.ArgumentParser(description='Git hook worker')
    parser.add_argument('--hook-type', type=str, help='Type of git hook being processed')
    
    args = parser.parse_args()
    
    if args.hook_type:
        process_git_hook(args.hook_type)
    else:
        handle_cli_commands()
```

6. **Ensure Compatibility with Existing Journal Workflow**:
```python
# Add this function to check if we can use the direct approach
def can_use_direct_journal_generation():
    """Check if we can use direct journal generation"""
    try:
        from journal_workflow import generate_journal_entry
        return True
    except ImportError:
        return False

# Fallback mechanism if needed
def process_git_hook_with_fallback(hook_type):
    """Process git hook with fallback to signal if direct approach fails"""
    try:
        git_context = collect_git_context()
        
        # Try direct approach first
        if can_use_direct_journal_generation():
            from journal_workflow import generate_journal_entry
            success = generate_journal_entry(git_context=git_context, hook_type=hook_type)
            if success:
                return True
        
        # Fallback to signal approach if direct approach fails or isn't available
        from signal_utils import create_tool_signal
        create_tool_signal('journal_generation', {
            'git_context': git_context,
            'hook_type': hook_type
        })
        return True
    except Exception as e:
        log_error(f"Git hook processing failed: {str(e)}")
        return False
```

7. **Update Tests for Direct Journal Generation**:
```python
def test_direct_journal_generation():
    """Test direct journal generation from git hook"""
    # Mock git context collection
    with patch('context_collection.collect_git_context') as mock_collect, \
         patch('journal_workflow.generate_journal_entry') as mock_generate:
        
        # Configure mocks
        mock_collect.return_value = {'commit_hash': 'test123'}
        mock_generate.return_value = True
        
        # Call the function
        result = process_git_hook('post-commit')
        
        # Verify correct function calls
        mock_collect.assert_called_once()
        mock_generate.assert_called_once_with(
            git_context={'commit_hash': 'test123'}, 
            hook_type='post-commit'
        )
        
        assert result is True
```

# Test Strategy:
To verify the refactored git hook worker is functioning correctly:

1. **Unit Testing Direct Journal Generation**:
   - Create unit tests for the refactored process_git_hook function:
     ```python
     def test_process_git_hook_direct_call():
         # Mock dependencies
         with patch('git_hook_worker.collect_git_context') as mock_git, \
              patch('journal_workflow.generate_journal_entry') as mock_generate, \
              patch('git_hook_worker.log_telemetry') as mock_telemetry:
             
             # Configure mocks
             mock_git.return_value = {'commit_hash': 'abc123'}
             mock_generate.return_value = True
             
             # Call function
             result = process_git_hook('post-commit')
             
             # Verify direct call to journal generation
             mock_git.assert_called_once()
             mock_generate.assert_called_once_with(
                 git_context={'commit_hash': 'abc123'},
                 hook_type='post-commit'
             )
             mock_telemetry.assert_called_once()
             
             assert result is True
     ```

2. **Test Error Handling**:
   - Verify that errors are properly handled:
     ```python
     def test_process_git_hook_error_handling():
         # Test with journal generation raising an exception
         with patch('git_hook_worker.collect_git_context') as mock_git, \
              patch('journal_workflow.generate_journal_entry', side_effect=Exception("Test error")), \
              patch('git_hook_worker.log_error') as mock_log:
             
             mock_git.return_value = {'commit_hash': 'abc123'}
             
             result = process_git_hook('post-commit')
             
             # Verify error was logged but not raised
             mock_log.assert_called_once()
             assert "Test error" in mock_log.call_args[0][0]
             assert result is False
     ```

3. **Test CLI Integration**:
   - Test the command-line interface:
     ```python
     def test_cli_generate_now():
         # Mock dependencies
         with patch('git_hook_worker.collect_git_context') as mock_git, \
              patch('journal_workflow.generate_journal_entry') as mock_generate, \
              patch('sys.argv', ['git_hook_worker.py', '--generate-now']), \
              patch('builtins.print') as mock_print:
             
             mock_git.return_value = {'commit_hash': 'abc123'}
             mock_generate.return_value = True
             
             # Call main function
             main()
             
             # Verify journal generation was called
             mock_git.assert_called_once()
             mock_generate.assert_called_once()
             mock_print.assert_called_with("Journal generation successful")
     ```

4. **Test Hook Execution**:
   - Test the hook execution path:
     ```python
     def test_hook_execution():
         # Mock dependencies
         with patch('git_hook_worker.process_git_hook') as mock_process, \
              patch('sys.argv', ['git_hook_worker.py', '--hook-type=post-commit']):
             
             mock_process.return_value = True
             
             # Call main function
             main()
             
             # Verify process_git_hook was called with correct hook type
             mock_process.assert_called_once_with('post-commit')
     ```

5. **Integration Test with Actual Journal Workflow**:
   - Create an integration test that verifies the actual journal generation:
     ```python
     def test_integration_with_journal_workflow():
         # Create a test git context
         test_git_context = {
             'commit_hash': 'test123',
             'branch': 'test-branch',
             'commit_message': 'Test commit',
             'diff': 'test diff content',
             'author': 'Test User',
             'timestamp': '1609459200'
         }
         
         # Mock git context collection but use real journal generation
         with patch('git_hook_worker.collect_git_context', return_value=test_git_context):
             # Create a temporary journal directory
             with tempfile.TemporaryDirectory() as temp_dir:
                 # Configure journal output to use temp directory
                 with patch('journal.get_journal_directory', return_value=temp_dir):
                     # Run the hook processing
                     result = process_git_hook('post-commit')
                     
                     # Verify journal file was created
                     today = datetime.now().strftime('%Y-%m-%d')
                     journal_path = os.path.join(temp_dir, f"{today}.md")
                     
                     assert os.path.exists(journal_path)
                     with open(journal_path, 'r') as f:
                         content = f.read()
                         assert 'Test commit' in content
                     
                     assert result is True
     ```

6. **Test Compatibility Check**:
   - Test the compatibility check function:
     ```python
     def test_can_use_direct_journal_generation():
         # Test when journal_workflow is available
         with patch.dict('sys.modules', {'journal_workflow': MagicMock()}):
             assert can_use_direct_journal_generation() is True
         
         # Test when journal_workflow is not available
         with patch.dict('sys.modules', {}, clear=True):
             with patch('builtins.__import__', side_effect=ImportError):
                 assert can_use_direct_journal_generation() is False
     ```

7. **Test Fallback Mechanism**:
   - Test the fallback to signal approach:
     ```python
     def test_process_git_hook_with_fallback():
         # Mock dependencies
         with patch('git_hook_worker.collect_git_context') as mock_git, \
              patch('git_hook_worker.can_use_direct_journal_generation', return_value=False), \
              patch('signal_utils.create_tool_signal') as mock_signal:
             
             mock_git.return_value = {'commit_hash': 'abc123'}
             
             # Call function
             result = process_git_hook_with_fallback('post-commit')
             
             # Verify fallback to signal
             mock_git.assert_called_once()
             mock_signal.assert_called_once_with('journal_generation', {
                 'git_context': {'commit_hash': 'abc123'},
                 'hook_type': 'post-commit'
             })
             
             assert result is True
     ```

8. **Manual Testing with Git Commits**:
   1. Install the refactored git hooks using the CLI tool
   2. Make a small code change and commit it
   3. Verify that a journal entry was generated in the journal directory
   4. Check that the journal entry contains relevant information about the commit
   5. Verify no signals were created in the process

9. **Performance Testing**:
   - Measure execution time to ensure it's suitable for a git hook:
     ```python
     def test_performance():
         start_time = time.time()
         process_git_hook('post-commit')
         execution_time = time.time() - start_time
         
         # Should complete in a reasonable time for a git hook
         assert execution_time < 5.0  # 5 seconds max
     ```

10. **Verify No Signal Dependencies**:
    - Create a test that ensures no signals are created:
      ```python
      def test_no_signals_created():
          # Mock dependencies including signal creation
          with patch('git_hook_worker.collect_git_context') as mock_git, \
               patch('journal_workflow.generate_journal_entry') as mock_generate, \
               patch('signal_utils.create_tool_signal') as mock_signal:
              
              mock_git.return_value = {'commit_hash': 'abc123'}
              mock_generate.return_value = True
              
              # Call function
              process_git_hook('post-commit')
              
              # Verify signal creation was not called
              mock_signal.assert_not_called()
      ```

# Subtasks:
## 1. Refactor git_hook_worker.py to Call Journal Generation Directly [pending]
### Dependencies: None
### Description: Update the process_git_hook function to directly call journal_workflow.generate_journal_entry() instead of creating signals.
### Details:
Modify the existing process_git_hook function to import and call journal_workflow.generate_journal_entry() directly with the collected git context. Remove any signal creation logic (create_tool_signal calls) while preserving all existing error handling and telemetry logging. Ensure the function maintains the same return value behavior (True for success, False for failure).

## 2. Update Import Statements and Dependencies [pending]
### Dependencies: None
### Description: Add necessary imports for journal_workflow and ensure all dependencies are properly managed.
### Details:
Add import statements for journal_workflow.generate_journal_entry at the top of git_hook_worker.py. Review and update any other imports that may be needed. Implement a can_use_direct_journal_generation() function to check if the direct approach is available, which can be used for graceful fallback if needed.

## 3. Update CLI Command Handler for Direct Journal Generation [pending]
### Dependencies: None
### Description: Modify the CLI command handler to use direct journal generation when the --generate-now flag is used.
### Details:
Update the handle_cli_commands function to directly call journal_workflow.generate_journal_entry when the --generate-now flag is provided, instead of creating a signal. Preserve all existing CLI options and help text. Ensure proper error handling and user feedback through console output.

## 4. Implement Fallback Mechanism for Compatibility [pending]
### Dependencies: None
### Description: Create a fallback mechanism that can use signal-based journal generation if direct generation fails.
### Details:
Implement a process_git_hook_with_fallback function that first attempts to use direct journal generation, but falls back to the signal approach if the direct method fails or isn't available. This ensures backward compatibility and graceful degradation if the journal workflow module can't be imported or encounters errors.

## 5. Update Tests for Direct Journal Generation [pending]
### Dependencies: None
### Description: Create new tests and update existing tests to verify the direct journal generation approach.
### Details:
Develop comprehensive tests for the refactored git_hook_worker.py, including unit tests for direct journal generation, error handling, CLI integration, and the fallback mechanism. Ensure all tests pass with the refactored implementation.

## 6. Verify Integration with Existing Journal Workflow [pending]
### Dependencies: None
### Description: Ensure the refactored git hook worker integrates correctly with the existing journal workflow.
### Details:
Perform integration testing to verify that the refactored git hook worker correctly calls the journal workflow and generates journal entries. Test with actual git commits to ensure the end-to-end flow works as expected. Verify that no signals are created in the process.

