{
  "tasks": [
    {
      "id": 11,
      "title": "Implement Summary Generation",
      "description": "Create the functionality to generate daily, weekly, monthly, quarterly, and yearly summaries of journal entries, with special emphasis on manual reflections.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "Implement summary generation in the MCP server with the following features:\n\n1. Date range utilities:\n```python\ndef get_date_range(period, date=None):\n    \"\"\"Get start and end dates for a period\"\"\"\n    if date is None:\n        date = datetime.now().date()\n    elif isinstance(date, str):\n        date = datetime.strptime(date, \"%Y-%m-%d\").date()\n    \n    if period == \"day\":\n        return date, date\n    elif period == \"week\":\n        # Start of week (Monday)\n        start = date - timedelta(days=date.weekday())\n        end = start + timedelta(days=6)\n        return start, end\n    elif period == \"month\":\n        start = date.replace(day=1)\n        # Last day of month\n        next_month = date.replace(day=28) + timedelta(days=4)\n        end = next_month - timedelta(days=next_month.day)\n        return start, end\n    elif period == \"quarter\":\n        # Determine which quarter the date falls in\n        quarter = (date.month - 1) // 3 + 1\n        # Start of quarter (first day of first month in quarter)\n        start_month = (quarter - 1) * 3 + 1\n        start = date.replace(month=start_month, day=1)\n        # End of quarter (last day of last month in quarter)\n        end_month = quarter * 3\n        end_day = 31 if end_month in [3, 12] else 30 if end_month in [6, 9] else 28\n        if end_month == 2 and (date.year % 4 == 0 and (date.year % 100 != 0 or date.year % 400 == 0)):\n            end_day = 29  # Leap year\n        end = date.replace(month=end_month, day=end_day)\n        return start, end\n    elif period == \"year\":\n        start = date.replace(month=1, day=1)\n        end = date.replace(month=12, day=31)\n        return start, end\n    else:\n        raise ValueError(f\"Unknown period: {period}\")\n```\n\n2. Journal file collection:\n```python\ndef get_journal_files_in_range(start_date, end_date, config):\n    \"\"\"Get journal files in date range\"\"\"\n    files = []\n    current = start_date\n    while current <= end_date:\n        file_path = Path(config[\"journal\"][\"path\"]) / \"daily\" / f\"{current.strftime('%Y-%m-%d')}.md\"\n        if file_path.exists():\n            files.append(file_path)\n        current += timedelta(days=1)\n    return files\n```\n\n3. Summary generation with manual reflection prioritization:\n```python\ndef generate_summary(files, period, config):\n    \"\"\"Generate summary from journal files\"\"\"\n    # Extract content from files\n    entries = []\n    manual_reflections = []\n    \n    for file_path in files:\n        with open(file_path, \"r\") as f:\n            content = f.read()\n            # Extract entries and reflections\n            # Extract manual reflections from special sections\n            reflection_sections = extract_manual_reflections(content, file_path.stem)\n            if reflection_sections:\n                manual_reflections.extend(reflection_sections)\n            # Extract regular entries\n            # Implementation\n    \n    # Analyze entries for significance/complexity\n    weighted_entries = []\n    for entry in entries:\n        # Determine entry significance based on factors like:\n        # - Length/detail of the entry\n        # - Presence of technical terms or complex concepts\n        # - Keywords indicating substantial work (\"implemented\", \"designed\", \"solved\")\n        # - Absence of trivial indicators (\"minor fix\", \"typo\", \"small change\")\n        significance_score = calculate_entry_significance(entry)\n        weighted_entries.append((entry, significance_score))\n    \n    # Sort entries by significance score to prioritize important work\n    weighted_entries.sort(key=lambda x: x[1], reverse=True)\n    \n    # Generate summary sections\n    summary = []\n    \n    # Add manual reflections section first - always prioritized\n    if manual_reflections:\n        summary.append(\"# ðŸ“ Manual Reflections\\n\")\n        summary.append(\"*These are your own reflections from the period, presented verbatim.*\\n\")\n        formatted_reflections = []\n        for date, reflection in manual_reflections:\n            formatted_reflections.append(f\"## {date}\\n\\n{reflection}\\n\")\n        summary.append(\"\\n\".join(formatted_reflections))\n    \n    # Add other sections\n    summary.append(\"# Summary\\n\")\n    # Generate overall summary with emphasis on significant entries\n    \n    summary.append(\"# Key Accomplishments\\n\")\n    # Extract accomplishments, prioritizing substantial work\n    \n    summary.append(\"# Challenges\\n\")\n    # Extract challenges, focusing on complex problems\n    \n    summary.append(\"# Technical Decisions\\n\")\n    # Extract decisions, highlighting important architectural choices\n    \n    return \"\\n\\n\".join(summary)\n\ndef extract_manual_reflections(content, date_str):\n    \"\"\"Extract manual reflections from journal content\"\"\"\n    reflections = []\n    \n    # Look for reflection sections with patterns like:\n    # ## Reflection\n    # ## Daily Reflection\n    # ## Personal Reflection\n    # etc.\n    \n    reflection_patterns = [\n        r\"#+\\s*(?:Daily\\s*)?Reflection[s]?\\s*\\n([\\s\\S]*?)(?:\\n#+\\s|$)\",\n        r\"#+\\s*(?:Personal\\s*)?Thought[s]?\\s*\\n([\\s\\S]*?)(?:\\n#+\\s|$)\",\n        r\"#+\\s*(?:Manual\\s*)?Note[s]?\\s*\\n([\\s\\S]*?)(?:\\n#+\\s|$)\"\n    ]\n    \n    for pattern in reflection_patterns:\n        matches = re.finditer(pattern, content, re.MULTILINE)\n        for match in matches:\n            reflection_text = match.group(1).strip()\n            if reflection_text:  # Only add non-empty reflections\n                reflections.append((date_str, reflection_text))\n    \n    return reflections\n\ndef calculate_entry_significance(entry):\n    \"\"\"Calculate significance score for an entry to prioritize substantial work\"\"\"\n    score = 0\n    \n    # Base score from length (longer entries often indicate more substantial work)\n    score += min(len(entry) / 100, 5)  # Cap at 5 points for length\n    \n    # Keywords indicating substantial work\n    substantial_indicators = [\n        \"implement\", \"design\", \"architecture\", \"refactor\", \"optimize\", \n        \"solve\", \"complex\", \"challenge\", \"significant\", \"major\"\n    ]\n    \n    # Keywords indicating trivial work\n    trivial_indicators = [\n        \"typo\", \"minor fix\", \"small change\", \"tweak\", \"trivial\", \n        \"cosmetic\", \"rename\", \"formatting\"\n    ]\n    \n    # Add points for substantial work indicators\n    for word in substantial_indicators:\n        if word in entry.lower():\n            score += 2\n    \n    # Subtract points for trivial work indicators\n    for word in trivial_indicators:\n        if word in entry.lower():\n            score -= 1.5\n    \n    # Analyze for technical complexity\n    # (This could be enhanced with more sophisticated NLP in the future)\n    technical_terms = [\"algorithm\", \"database\", \"architecture\", \"performance\", \"security\"]\n    for term in technical_terms:\n        if term in entry.lower():\n            score += 1\n    \n    return max(score, 0)  # Ensure score doesn't go negative\n```\n\n4. Summary file saving:\n```python\ndef save_summary(content, period, date, config):\n    \"\"\"Save summary to appropriate file\"\"\"\n    if period == \"day\":\n        file_name = f\"{date.strftime('%Y-%m-%d')}-summary.md\"\n        dir_path = Path(config[\"journal\"][\"path\"]) / \"summaries\" / \"daily\"\n    elif period == \"week\":\n        # Get week number\n        week_num = date.isocalendar()[1]\n        file_name = f\"{date.strftime('%Y-%m')}-week{week_num}.md\"\n        dir_path = Path(config[\"journal\"][\"path\"]) / \"summaries\" / \"weekly\"\n    elif period == \"month\":\n        file_name = f\"{date.strftime('%Y-%m')}.md\"\n        dir_path = Path(config[\"journal\"][\"path\"]) / \"summaries\" / \"monthly\"\n    elif period == \"quarter\":\n        # Determine which quarter the date falls in\n        quarter = (date.month - 1) // 3 + 1\n        file_name = f\"{date.strftime('%Y')}-Q{quarter}.md\"\n        dir_path = Path(config[\"journal\"][\"path\"]) / \"summaries\" / \"quarterly\"\n    elif period == \"year\":\n        file_name = f\"{date.strftime('%Y')}.md\"\n        dir_path = Path(config[\"journal\"][\"path\"]) / \"summaries\" / \"yearly\"\n    else:\n        raise ValueError(f\"Unknown period: {period}\")\n    \n    # Create file path\n    file_path = dir_path / file_name\n    \n    # Ensure directory exists using on-demand directory creation pattern\n    ensure_journal_directory(dir_path)\n    \n    # Save file\n    with open(file_path, \"w\") as f:\n        f.write(content)\n    \n    return file_path\n```\n\n5. MCP handler implementation:\n```python\n@trace_operation(\"journal_summarize\")\nasync def handle_summarize(request):\n    \"\"\"Handle journal/summarize operation\"\"\"\n    period = request.get(\"period\", \"day\")\n    date = request.get(\"date\")\n    date_range = request.get(\"range\")\n    \n    # Load config\n    config = load_config()\n    \n    # Get date range\n    if date_range:\n        # Parse range (format: \"YYYY-MM-DD:YYYY-MM-DD\")\n        start_str, end_str = date_range.split(\":\")\n        start_date = datetime.strptime(start_str, \"%Y-%m-%d\").date()\n        end_date = datetime.strptime(end_str, \"%Y-%m-%d\").date()\n    else:\n        start_date, end_date = get_date_range(period, date)\n    \n    # Get journal files\n    files = get_journal_files_in_range(start_date, end_date, config)\n    if not files:\n        return {\"status\": \"error\", \"error\": \"No journal entries found in date range\"}\n    \n    # Generate summary\n    content = generate_summary(files, period, config)\n    \n    # Save summary\n    file_path = save_summary(content, period, start_date, config)\n    \n    return {\n        \"status\": \"success\",\n        \"file_path\": str(file_path),\n        \"content\": content\n    }\n```\n\n6. Directory creation utility:\n```python\ndef ensure_journal_directory(dir_path):\n    \"\"\"Ensure the journal directory exists, creating it if necessary\"\"\"\n    if not dir_path.exists():\n        dir_path.mkdir(parents=True, exist_ok=True)\n        logger.info(f\"Created directory: {dir_path}\")\n    return dir_path\n```\n\n7. On-demand directory creation pattern:\n- All summary file-writing operations must use the on-demand directory creation pattern\n- Directories should only be created when needed, not upfront\n- All summary-writing functions (including save_summary) must call ensure_journal_directory(file_path) before writing\n- See docs/on-demand-directory-pattern.md for implementation details and test patterns\n\n8. Manual reflection prioritization:\n- Manual reflections must be prominently displayed at the beginning of summaries\n- Use visual distinction (emoji, formatting) to highlight manual reflections\n- Include date context for each reflection\n- Preserve the original wording of manual reflections\n- Implement reflection extraction from common section patterns\n- Ensure manual reflections are always prioritized over inferred content\n\nNote: This implementation focuses solely on MCP/AI agent operations for summary generation. CLI functionality is limited to setup commands (journal-init, install-hook) only. Refer to updated documentation for details.",
      "testStrategy": "1. Unit tests for date range utilities\n   - Test all periods (day, week, month, quarter, year)\n   - Test edge cases like quarter boundaries\n   - Test leap year handling for February in quarterly calculations\n2. Tests for journal file collection\n3. Tests for summary generation\n4. Tests for summary file saving\n   - Test saving for all periods (daily, weekly, monthly, quarterly, yearly)\n   - Test correct file naming for quarterly summaries (YYYY-Q1, YYYY-Q2, etc.)\n5. Tests for MCP handler implementation\n6. Tests for handling different periods (day, week, month, quarter, year)\n7. Tests for handling date ranges\n8. Integration tests for full summary generation flow\n9. Tests for entry significance calculation\n10. Tests to verify that substantial work is properly prioritized in summaries\n11. Tests to verify that trivial entries are de-emphasized in summaries\n12. Tests with mixed entry types to ensure proper weighting in the final summary\n13. Tests for on-demand directory creation:\n    - Test that summary directories are created automatically when they don't exist\n    - Test that ensure_journal_directory() is called for all summary types (daily, weekly, monthly, quarterly, yearly)\n    - Test that directory creation works with nested paths\n    - Test that no errors occur when directories already exist\n    - Test that directories are only created when needed, not upfront\n    - Verify that all summary-writing functions call ensure_journal_directory() before writing\n    - Follow test patterns described in docs/on-demand-directory-pattern.md\n14. Tests to verify that summarization is available as an MCP operation\n15. Tests to verify that the AI agent can properly interact with the summarization functionality\n16. Verify that summary generation works correctly through the MCP interface only (not CLI)\n17. Test that the AI agent can request summaries for different time periods and date ranges\n18. Tests for manual reflection extraction:\n    - Test extraction from various section formats (## Reflection, ## Daily Reflection, etc.)\n    - Test with multiple reflection sections in a single file\n    - Test with reflection sections containing various formatting (lists, code blocks, etc.)\n    - Test with empty reflection sections\n    - Test with reflection sections at different positions in the file\n19. Tests for manual reflection prioritization:\n    - Verify that manual reflections appear at the beginning of summaries\n    - Verify that manual reflections are visually distinguished\n    - Verify that date context is included for each reflection\n    - Verify that original wording is preserved\n    - Test with mixed content (manual reflections and regular entries)\n    - Test with only manual reflections\n    - Test with no manual reflections\n20. Tests for quarterly summary generation:\n    - Test correct date range calculation for each quarter\n    - Test correct file naming (YYYY-Q1, YYYY-Q2, etc.)\n    - Test with entries spanning multiple months within a quarter\n    - Test with entries at quarter boundaries",
      "subtasks": [
        {
          "id": "11.1",
          "title": "Implement entry significance calculation",
          "description": "Create the algorithm to analyze journal entries and assign significance scores based on content analysis.",
          "status": "pending"
        },
        {
          "id": "11.2",
          "title": "Modify summary generation to prioritize significant entries",
          "description": "Update the summary generation logic to give more narrative weight to entries with higher significance scores.",
          "status": "pending"
        },
        {
          "id": "11.3",
          "title": "Create test cases for entry significance calculation",
          "description": "Develop test cases with various types of entries (substantial, trivial, mixed) to verify proper significance scoring.",
          "status": "pending"
        },
        {
          "id": "11.4",
          "title": "Test summary prioritization with real-world examples",
          "description": "Test the summary generation with a set of real-world journal entries to ensure meaningful work is properly highlighted.",
          "status": "pending"
        },
        {
          "id": "11.5",
          "title": "Implement ensure_journal_directory utility",
          "description": "Create the utility function to ensure journal directories exist, creating them on-demand if necessary.",
          "status": "pending"
        },
        {
          "id": "11.6",
          "title": "Update save_summary to use ensure_journal_directory",
          "description": "Modify the save_summary function to use the ensure_journal_directory utility for all summary types.",
          "status": "pending"
        },
        {
          "id": "11.7",
          "title": "Add tests for directory creation functionality",
          "description": "Create tests to verify that summary directories are created automatically when they don't exist and that the ensure_journal_directory utility works correctly.",
          "status": "pending"
        },
        {
          "id": "11.8",
          "title": "Implement on-demand directory creation pattern",
          "description": "Update all summary file-writing operations to follow the on-demand directory creation pattern as described in docs/on-demand-directory-pattern.md.",
          "status": "pending"
        },
        {
          "id": "11.9",
          "title": "Add tests for on-demand directory creation",
          "description": "Create tests to verify that directories are only created when needed, not upfront, and that all summary-writing functions call ensure_journal_directory() before writing.",
          "status": "pending"
        },
        {
          "id": "11.10",
          "title": "Review and update all file-writing operations",
          "description": "Review all file-writing operations in the codebase to ensure they follow the on-demand directory creation pattern.",
          "status": "pending"
        },
        {
          "id": "11.11",
          "title": "Verify MCP operation for summarization",
          "description": "Ensure that summarization is properly implemented as an MCP operation and accessible to the AI agent.",
          "status": "pending"
        },
        {
          "id": "11.12",
          "title": "Test AI agent interaction with summarization",
          "description": "Create tests to verify that the AI agent can properly request and process summary generation through the MCP server.",
          "status": "pending"
        },
        {
          "id": "11.13",
          "title": "Ensure summary generation is MCP-only",
          "description": "Verify that summary generation functionality is only available through the MCP interface and not through CLI commands.",
          "status": "pending"
        },
        {
          "id": "11.14",
          "title": "Update documentation to reflect MCP-only approach",
          "description": "Update relevant documentation to clarify that summary generation is only available through the MCP/AI agent interface, not through CLI commands.",
          "status": "pending"
        },
        {
          "id": "11.15",
          "title": "Implement manual reflection extraction",
          "description": "Create functionality to extract manual reflections from journal entries using pattern matching for common section headers.",
          "status": "pending"
        },
        {
          "id": "11.16",
          "title": "Implement manual reflection prioritization in summaries",
          "description": "Update summary generation to display manual reflections prominently at the beginning with visual distinction and date context.",
          "status": "pending"
        },
        {
          "id": "11.17",
          "title": "Add tests for manual reflection extraction",
          "description": "Create tests to verify that manual reflections are correctly extracted from various section formats and positions.",
          "status": "pending"
        },
        {
          "id": "11.18",
          "title": "Add tests for manual reflection prioritization",
          "description": "Create tests to verify that manual reflections appear at the beginning of summaries with proper visual distinction and preserved wording.",
          "status": "pending"
        },
        {
          "id": "11.19",
          "title": "Implement quarterly summary support",
          "description": "Add support for generating quarterly summaries, including date range calculation and file naming conventions.",
          "status": "pending"
        },
        {
          "id": "11.20",
          "title": "Create tests for quarterly summary generation",
          "description": "Develop tests to verify correct date range calculation, file naming, and content generation for quarterly summaries.",
          "status": "pending"
        },
        {
          "id": "11.21",
          "title": "Update documentation to include quarterly summaries",
          "description": "Update relevant documentation to include information about quarterly summary generation and usage.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 12,
      "title": "Implement Blog Post Generation",
      "description": "Create the functionality to convert journal entries and summaries into blog post format for storytelling.",
      "details": "Implement blog post generation in both the MCP server and CLI with the following features:\n\n1. Blog post generation:\n```python\ndef generate_blog_post(files, config):\n    \"\"\"Generate blog post from journal files\"\"\"\n    # Extract content from files\n    entries = []\n    \n    for file_path in files:\n        with open(file_path, \"r\") as f:\n            content = f.read()\n            # Extract entries\n            # Implementation\n    \n    # Generate blog post sections\n    blog_post = []\n    \n    # Add title and introduction\n    blog_post.append(\"# Project Journey: From Idea to Implementation\\n\")\n    blog_post.append(\"*An engineering story based on journal entries*\\n\")\n    \n    # Add narrative sections\n    blog_post.append(\"## The Challenge\\n\")\n    # Generate challenge narrative\n    \n    blog_post.append(\"## The Approach\\n\")\n    # Generate approach narrative\n    \n    blog_post.append(\"## Key Decisions\\n\")\n    # Extract and narrate decisions\n    \n    blog_post.append(\"## Lessons Learned\\n\")\n    # Extract and narrate lessons\n    \n    blog_post.append(\"## Conclusion\\n\")\n    # Generate conclusion\n    \n    return \"\\n\\n\".join(blog_post)\n```\n\n2. Blog post file saving:\n```python\ndef save_blog_post(content, title, config):\n    \"\"\"Save blog post to file\"\"\"\n    # Create directory if needed\n    dir_path = Path(config[\"journal\"][\"path\"]) / \"blog_posts\"\n    dir_path.mkdir(parents=True, exist_ok=True)\n    \n    # Generate file name from title\n    file_name = title.lower().replace(\" \", \"-\") + \".md\"\n    file_path = dir_path / file_name\n    \n    # Save file\n    with open(file_path, \"w\") as f:\n        f.write(content)\n    \n    return file_path\n```\n\n3. MCP handler implementation:\n```python\n@trace_operation(\"journal_blogify\")\nasync def handle_blogify(request):\n    \"\"\"Handle journal/blogify operation\"\"\"\n    files = request.get(\"files\", [])\n    title = request.get(\"title\", \"Engineering Journey\")\n    \n    if not files:\n        return {\"status\": \"error\", \"error\": \"No files provided\"}\n    \n    # Load config\n    config = load_config()\n    \n    # Convert file paths to Path objects\n    file_paths = [Path(f) for f in files]\n    \n    # Check if files exist\n    missing = [str(f) for f in file_paths if not f.exists()]\n    if missing:\n        return {\"status\": \"error\", \"error\": f\"Files not found: {', '.join(missing)}\"}\n    \n    # Generate blog post\n    content = generate_blog_post(file_paths, config)\n    \n    # Save blog post\n    file_path = save_blog_post(content, title, config)\n    \n    return {\n        \"status\": \"success\",\n        \"file_path\": str(file_path),\n        \"content\": content\n    }\n```\n\n4. CLI command implementation:\n```python\n@cli.command()\n@click.argument(\"files\", nargs=-1, type=click.Path(exists=True))\n@click.option(\"--title\", default=\"Engineering Journey\", help=\"Blog post title\")\n@click.option(\"--debug\", is_flag=True, help=\"Show debug information\")\ndef blogify(files, title, debug):\n    \"\"\"Convert journal entries to blog post\"\"\"\n    try:\n        if not files:\n            click.echo(\"No files provided\")\n            return\n        \n        # Load config\n        config = load_config()\n        \n        # Convert file paths to Path objects\n        file_paths = [Path(f) for f in files]\n        \n        # Generate blog post\n        content = generate_blog_post(file_paths, config)\n        \n        # Save blog post\n        file_path = save_blog_post(content, title, config)\n        \n        click.echo(f\"Blog post saved to {file_path}\")\n    except Exception as e:\n        if debug:\n            click.echo(f\"Error: {e}\")\n            traceback.print_exc()\n        else:\n            click.echo(f\"Error: {e}\")\n```",
      "testStrategy": "1. Unit tests for blog post generation\n2. Tests for blog post file saving\n3. Tests for MCP handler implementation\n4. Tests for CLI command implementation\n5. Tests for handling multiple input files\n6. Tests for narrative generation\n7. Integration tests for full blog post generation flow",
      "priority": "low",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Backfill Functionality",
      "description": "Create the functionality to detect and generate journal entries for missed commits.",
      "details": "Implement backfill functionality in both the MCP server and CLI with the following features:\n\n1. Missed commit detection:\n```python\ndef get_missed_commits(repo, config):\n    \"\"\"Get commits that don't have journal entries\"\"\"\n    # Get journal directory\n    journal_path = Path(config[\"journal\"][\"path\"])\n    \n    # Get all commits\n    commits = list(repo.iter_commits())\n    \n    # Get all journal files\n    journal_files = list(journal_path.glob(\"daily/*.md\"))\n    \n    # Extract commit hashes from journal files\n    journal_commits = set()\n    for file_path in journal_files:\n        with open(file_path, \"r\") as f:\n            content = f.read()\n            # Extract commit hashes using regex\n            # Implementation\n    \n    # Find commits not in journal\n    missed_commits = []\n    for commit in commits:\n        if commit.hexsha not in journal_commits and not is_journal_only_commit(commit, config[\"journal\"][\"path\"]):\n            missed_commits.append(commit)\n    \n    return missed_commits\n```\n\n2. Backfill processing:\n```python\ndef process_backfill(commits, config, debug=False):\n    \"\"\"Process backfill for missed commits\"\"\"\n    results = []\n    \n    # Sort commits by date\n    commits.sort(key=lambda c: c.committed_date)\n    \n    for commit in commits:\n        # Generate entry\n        entry = generate_journal_entry(commit, config, debug)\n        if not entry:\n            continue\n        \n        # Mark as backfilled\n        entry.is_backfilled = True\n        \n        # Save entry\n        file_path = save_journal_entry(entry, config)\n        \n        results.append({\n            \"commit\": commit.hexsha,\n            \"file_path\": str(file_path)\n        })\n    \n    return results\n```\n\n3. MCP handler implementation:\n```python\n@trace_operation(\"journal_backfill\")\nasync def handle_backfill(request):\n    \"\"\"Handle journal/backfill operation\"\"\"\n    debug = request.get(\"debug\", False)\n    \n    # Load config\n    config = load_config()\n    \n    # Get repo\n    repo = get_repo()\n    \n    # Get missed commits\n    missed_commits = get_missed_commits(repo, config)\n    if not missed_commits:\n        return {\"status\": \"success\", \"message\": \"No missed commits found\"}\n    \n    # Process backfill\n    results = process_backfill(missed_commits, config, debug)\n    \n    return {\n        \"status\": \"success\",\n        \"count\": len(results),\n        \"entries\": results\n    }\n```\n\n4. CLI command implementation:\n```python\n@cli.command()\n@click.option(\"--debug\", is_flag=True, help=\"Show debug information\")\ndef backfill(debug):\n    \"\"\"Check for missed commits and create entries\"\"\"\n    try:\n        # Load config\n        config = load_config()\n        \n        # Get repo\n        repo = get_repo()\n        \n        # Get missed commits\n        missed_commits = get_missed_commits(repo, config)\n        if not missed_commits:\n            click.echo(\"No missed commits found\")\n            return\n        \n        # Process backfill\n        results = process_backfill(missed_commits, config, debug)\n        \n        click.echo(f\"Created {len(results)} journal entries for missed commits\")\n        for result in results:\n            click.echo(f\"  - {result['commit'][:8]}: {result['file_path']}\")\n    except Exception as e:\n        if debug:\n            click.echo(f\"Error: {e}\")\n            traceback.print_exc()\n        else:\n            click.echo(f\"Error: {e}\")\n```",
      "testStrategy": "1. Unit tests for missed commit detection\n2. Tests for backfill processing\n3. Tests for MCP handler implementation\n4. Tests for CLI command implementation\n5. Tests for handling journal-only commits\n6. Tests for chronological ordering of backfilled entries\n7. Integration tests for full backfill flow",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Create Comprehensive Tests and Documentation",
      "description": "Develop comprehensive tests for all components and create documentation for the project.",
      "status": "pending",
      "dependencies": [
        11,
        12,
        13
      ],
      "priority": "high",
      "details": "Create comprehensive tests and documentation with the following features:\n\n1. Test fixtures:\n```python\n@pytest.fixture\ndef mock_git_repo():\n    \"\"\"Create temporary git repo with test commits\"\"\"\n    # Implementation\n\n@pytest.fixture\ndef sample_journal_entries():\n    \"\"\"Load sample journal files\"\"\"\n    # Implementation\n\n@pytest.fixture\ndef mock_terminal_history():\n    \"\"\"Provide test terminal command history\"\"\"\n    # Implementation\n\n@pytest.fixture\ndef mock_chat_history():\n    \"\"\"Provide test chat history\"\"\"\n    # Implementation\n\n@pytest.fixture\ndef mock_telemetry_exporter():\n    \"\"\"Provide a test exporter that captures telemetry events\"\"\"\n    # Implementation\n```\n\n2. Unit tests:\n```python\ndef test_config_loading():\n    \"\"\"Test configuration loading\"\"\"\n    # Implementation\n\ndef test_git_utils():\n    \"\"\"Test git utilities\"\"\"\n    # Implementation\n\ndef test_journal_entry_generation():\n    \"\"\"Test journal entry generation\"\"\"\n    # Implementation\n\ndef test_telemetry():\n    \"\"\"Test telemetry integration\"\"\"\n    # Implementation\n\n# Additional unit tests for all components\n```\n\n3. Integration tests:\n```python\ndef test_cli_init():\n    \"\"\"Test CLI init command\"\"\"\n    # Implementation\n\ndef test_cli_new_entry():\n    \"\"\"Test CLI new-entry command\"\"\"\n    # Implementation\n\ndef test_mcp_server():\n    \"\"\"Test MCP server operations\"\"\"\n    # Implementation\n\n# Additional integration tests for all workflows\n```\n\n4. Documentation:\n   - README.md with project overview, installation, and usage\n   - Configuration documentation\n   - CLI command reference\n   - MCP server API reference\n   - Development guide\n   - Examples and tutorials\n\n5. Test coverage:\n   - Configure pytest-cov for coverage reporting\n   - Ensure >90% test coverage\n   - Add coverage reporting to CI pipeline\n\n6. Documentation structure:\n```\nREADME.md\ndocs/\nâ”œâ”€â”€ configuration.md\nâ”œâ”€â”€ cli.md\nâ”œâ”€â”€ mcp-server.md\nâ”œâ”€â”€ development.md\nâ””â”€â”€ examples/\n    â”œâ”€â”€ basic-usage.md\n    â”œâ”€â”€ custom-configuration.md\n    â””â”€â”€ integration-examples.md\n```",
      "testStrategy": "1. Verify test coverage meets >90% threshold\n2. Ensure all components have unit tests\n3. Verify integration tests cover all workflows\n4. Test documentation for accuracy and completeness\n5. Verify examples work as documented\n6. Test installation and usage instructions\n7. Verify CI pipeline runs all tests\n8. Ensure telemetry system is thoroughly tested with both unit and integration tests",
      "subtasks": [
        {
          "id": "15.1",
          "title": "Implement telemetry-specific tests",
          "description": "Create comprehensive tests for the telemetry system implemented in task 4",
          "status": "pending",
          "details": "Develop unit and integration tests for the telemetry infrastructure including:\n1. Test telemetry event generation\n2. Test telemetry data collection\n3. Test telemetry exporters\n4. Test telemetry configuration options\n5. Test telemetry integration with other components"
        },
        {
          "id": "15.2",
          "title": "Document telemetry system",
          "description": "Create documentation for the telemetry system",
          "status": "pending",
          "details": "Add telemetry documentation including:\n1. Overview of telemetry capabilities\n2. Configuration options for telemetry\n3. How to extend telemetry with custom exporters\n4. Privacy considerations\n5. Add a telemetry.md file to the docs directory"
        }
      ]
    },
    {
      "id": 19,
      "title": "Document MCP Server Configuration and Integration",
      "description": "Ensure the MCP server launch/discovery/configuration requirements are documented in the PRD, README, and codebase. The MCP server must be launchable as a standalone process, expose the required journal operations, and be discoverable by compatible clients. The method for launching the MCP server is not prescribed; it may be started via CLI, Python entry point, etc.",
      "details": "",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Provide generic client/editor config block example",
          "description": "Add a JSON example of a configuration block for connecting to the MCP server, showing command, args, and optional env vars.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 19
        },
        {
          "id": 2,
          "title": "Clarify API key/env var requirements",
          "description": "Document that API keys or environment variables are only required if the underlying SDK or provider needs them, not for all deployments.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 19
        },
        {
          "id": 3,
          "title": "Ensure separation of MCP server config from journal config",
          "description": "Make sure documentation clearly distinguishes between MCP server configuration and the journal system's .mcp-journalrc.yaml.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 19
        },
        {
          "id": 4,
          "title": "Review and update README/docs",
          "description": "Review and update the README.md and other documentation to reflect changes made in this task. Ensure documentation is clear, accurate, and up to date.",
          "details": "",
          "status": "pending",
          "dependencies": [
            "19.1",
            "19.2",
            "19.3"
          ],
          "parentTaskId": 19
        }
      ]
    },
    {
      "id": 21,
      "title": "Integrate Codecov for Test Coverage Reporting",
      "description": "Set up Codecov integration with the GitHub repository to track and report test coverage metrics, culminating in a functional coverage badge in the README.",
      "details": "This task involves establishing a connection between the repository and Codecov to enable automated test coverage reporting. Implementation steps include:\n\n1. Create a Codecov account if not already available and link it to the organization's GitHub account\n2. Add the repository to Codecov's dashboard\n3. Generate a Codecov token for secure communication between CI and Codecov\n4. Update the CI pipeline configuration (GitHub Actions, CircleCI, etc.) to:\n   - Install necessary coverage tools (e.g., pytest-cov for Python)\n   - Run tests with coverage collection enabled\n   - Upload coverage reports to Codecov using the token\n5. Add a `.codecov.yml` configuration file to the repository root to customize coverage settings (thresholds, exclusions, etc.)\n6. Uncomment or add the Codecov badge in the README.md file using the format provided by Codecov\n7. Verify the badge displays the actual coverage percentage after the first successful upload\n\nConsider setting coverage thresholds to maintain code quality and potentially configure PR comments from Codecov to highlight coverage changes in code reviews.",
      "testStrategy": "To verify successful completion of this task:\n\n1. Manually trigger a CI build and confirm the coverage report is generated and uploaded to Codecov\n2. Check the Codecov dashboard to ensure:\n   - The repository appears with correct coverage data\n   - Historical data begins tracking from the first upload\n   - Coverage reports include all relevant files (no critical omissions)\n3. Verify the Codecov badge in the README:\n   - Badge is properly displayed (not broken)\n   - Badge shows an actual percentage value (not \"unknown\" or \"N/A\")\n   - The percentage matches what's shown in the Codecov dashboard\n4. Create a test PR with code changes that would affect coverage (both positively and negatively) to confirm:\n   - Codecov reports the coverage change in the PR\n   - The badge updates accordingly after merging\n5. Document the integration process in the project documentation for future reference\n6. Have another team member verify they can access the Codecov dashboard for the repository",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "Implement Remaining MCP Server Handlers",
      "description": "Add the remaining non-MVP MCP tool handlers to complete the full feature set after their backend dependencies are implemented.",
      "status": "pending",
      "dependencies": [
        11,
        12,
        13
      ],
      "priority": "medium",
      "details": "Implement the remaining MCP server tool handlers in `src/mcp_commit_story/server.py` to complete the full feature set:\n\n1. **journal/summarize** handler:\n   - Depends on Task 11 (Summary Generation)\n   - Handle daily, weekly, monthly, yearly summary requests\n   - Return summary content and file paths\n   - Must use on-demand directory creation pattern\n\n2. **journal/blogify** handler:\n   - Depends on Task 12 (Blog Post Generation)\n   - Convert journal entries to blog post format\n   - Accept multiple file inputs\n   - Must use on-demand directory creation pattern\n\n3. **journal/backfill** handler:\n   - Depends on Task 13 (Backfill Functionality)\n   - Detect and create entries for missed commits\n   - Return list of created entries\n   - Must use on-demand directory creation pattern\n\n4. **journal/add-reflection** handler:\n   - Add reflection content to existing journal entries\n   - Accept entry path and reflection content\n   - Must use on-demand directory creation pattern\n\nAll handlers should:\n- Use existing `@handle_mcp_error` decorator\n- Follow TypedDict patterns established in Tasks 6.3-6.4\n- Include proper async/await support\n- Integrate with existing backend logic from their dependency tasks\n- Include comprehensive error handling and validation\n- Call ensure_journal_directory(file_path) before writing any files\n- Never create directories upfront - only on demand when needed\n- Implement as MCP operations only (no CLI commands required)\n- Focus exclusively on MCP/AI agent operations for file-writing handlers\n\nNote that the CLI functionality is limited to setup commands (journal-init, install-hook) only. All file-writing functionality must be implemented as MCP operations. Refer to the updated engineering spec and README.md for implementation details and test patterns.",
      "testStrategy": "1. Unit tests for each new handler\n2. Integration tests with backend logic\n3. Error handling validation\n4. End-to-end workflow testing\n5. Backward compatibility with existing handlers\n6. Verify on-demand directory creation pattern is used correctly\n7. Test that directories are only created when files are actually written\n8. Verify ensure_journal_directory() is called before file writes\n9. Verify all file-writing functionality is accessible via MCP operations only\n10. Test the journal/add-reflection handler functionality as an MCP operation",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "Create Packaging Strategy and Release Process for MVP Launch",
      "description": "Develop a comprehensive packaging and distribution strategy for the MCP Commit Story MVP, including PyPI publishing, version management, installation methods, and release processes.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "This task involves creating a complete packaging strategy and implementation plan for the MCP Commit Story MVP launch:\n\n1. **Distribution Strategy**:\n   - Set up PyPI package configuration with appropriate metadata in setup.py/pyproject.toml\n   - Implement semantic versioning (MAJOR.MINOR.PATCH) with version tracking in a dedicated file\n   - Configure CI/CD pipeline for automated releases using GitHub Actions or similar\n   - Define package dependencies with appropriate version constraints\n   - Create package structure with proper namespacing\n\n2. **Installation Methods**:\n   - Implement standard pip installation: `pip install mcp-commit-story`\n   - Create development installation process: `pip install -e .` with dev dependencies\n   - Document MCP server deployment options (standalone, Docker, etc.)\n   - Write detailed configuration guides for different environments\n\n3. **Release Process**:\n   - Implement automated version tagging and changelog generation\n   - Create pre-release testing checklist and validation procedures\n   - Set up documentation update workflow tied to releases\n   - Document rollback procedures for failed releases\n   - Establish release branch strategy (e.g., release/v1.0.0)\n   - Integrate with the Release Preparation Script (Task 30)\n\n4. **User Experience Documentation**:\n   - Write comprehensive getting started guide\n   - Create integration examples for VSCode, PyCharm, and command line\n   - Develop troubleshooting guide with common issues and solutions\n   - Set up community support channels (GitHub Discussions, Discord, etc.)\n   - Document the MCP Info Command functionality (Task 29)\n\n5. **Technical Implementation**:\n   - Define package structure with clear entry points\n   - Implement dependency management with compatibility matrices\n   - Create environment testing matrix (OS, Python versions)\n   - Document performance benchmarks and minimum requirements\n   - Ensure journal entry functionality is properly packaged and accessible\n   - Verify proper integration with the File-Based Logging System (Task 28)\n\nImplementation should follow Python packaging best practices and ensure the journal entry creation functionality from Task 9, daily summary git hook trigger from Task 27, logging system from Task 28, info command from Task 29, and release preparation script from Task 30 are all properly exposed and documented in the package.",
      "testStrategy": "To verify the packaging strategy and release process:\n\n1. **Package Structure Testing**:\n   - Validate package structure using `check-manifest`\n   - Verify all necessary files are included in the distribution\n   - Test package installation in a clean virtual environment\n   - Confirm entry points work as expected after installation\n\n2. **Release Process Validation**:\n   - Perform a test release to TestPyPI\n   - Verify version bumping and changelog generation\n   - Test the release automation pipeline with a pre-release version\n   - Validate rollback procedures with a simulated failed release\n   - Test the Release Preparation Script (Task 30) integration\n\n3. **Installation Testing**:\n   - Test pip installation on different operating systems (Windows, macOS, Linux)\n   - Verify development installation for contributors\n   - Test MCP server deployment using the documented methods\n   - Validate configuration options work as described\n\n4. **Documentation Review**:\n   - Conduct user testing with the getting started guide\n   - Review integration examples for accuracy and completeness\n   - Verify troubleshooting documentation addresses common issues\n   - Test community support channels are properly set up\n   - Verify MCP Info Command (Task 29) documentation is accurate\n\n5. **Functionality Testing**:\n   - Verify journal entry creation (from Task 9) works correctly after package installation\n   - Test daily summary git hook trigger (from Task 27) functions properly\n   - Validate the File-Based Logging System (Task 28) works as expected\n   - Test the MCP Info Command (Task 29) functionality\n   - Verify the Release Preparation Script (Task 30) executes correctly\n   - Test all documented features are accessible through the package\n   - Validate performance meets the documented benchmarks\n   - Ensure compatibility with all supported Python versions and environments\n\nThe packaging strategy is considered complete when a test user can successfully install and use the package following only the provided documentation.",
      "subtasks": [
        {
          "id": "26.1",
          "title": "Package Structure and Basic Configuration",
          "description": "Set up the foundational package structure with proper entry points, dependencies, and basic metadata in pyproject.toml",
          "status": "pending",
          "dependencies": [],
          "details": "**Objective**: Set up the foundational package structure with proper entry points, dependencies, and basic metadata in pyproject.toml\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_package_structure.py`\n   - Test `check_package_installability()` function\n   - Test cases: package can be installed via pip, entry points are accessible, required dependencies are installed, package metadata is correct, module imports work properly\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Package name decision (mcp-commit-story vs alternatives)\n   - **PAUSE FOR MANUAL APPROVAL**: Entry point structure and CLI command naming\n   - **PAUSE FOR MANUAL APPROVAL**: Dependency version constraints strategy (pinned vs flexible)\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement proper pyproject.toml configuration with metadata, dependencies, and entry points\n   - Create package structure with `__init__.py` files and proper imports\n   - Set up entry points for CLI and MCP server functionality\n   - Handle all error cases identified in tests\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create installation.md with package structure documentation\n     2. **PRD**: Update product requirements to reflect packaging strategy and installation methods\n     3. **Engineering Spec**: Update technical implementation details for package architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**"
        },
        {
          "id": "26.2",
          "title": "Version Management and PyPI Metadata",
          "description": "Implement semantic versioning system and complete PyPI package metadata for public distribution",
          "status": "pending",
          "dependencies": [],
          "details": "**Objective**: Implement semantic versioning system and complete PyPI package metadata for public distribution\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_version_management.py`\n   - Test `get_version()`, `validate_version_format()`, and `increment_version()` functions\n   - Test cases: version extraction from pyproject.toml, semantic version validation, version comparison, changelog integration, PyPI metadata validation\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Initial version number for MVP (0.1.0 vs 1.0.0 vs other)\n   - **PAUSE FOR MANUAL APPROVAL**: PyPI package description, keywords, and classifiers\n   - **PAUSE FOR MANUAL APPROVAL**: Author information and project URLs structure\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement version management utilities in `src/mcp_commit_story/version.py`\n   - Complete PyPI metadata in pyproject.toml with description, classifiers, urls\n   - Create version validation and update mechanisms\n   - Handle all error cases identified in tests\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update installation.md with version information and PyPI details\n     2. **PRD**: Update product requirements to reflect versioning strategy and public availability\n     3. **Engineering Spec**: Update technical implementation details for version management and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**"
        },
        {
          "id": "26.3",
          "title": "CI/CD Pipeline and Automated Release Process",
          "description": "Create GitHub Actions workflow for automated testing, building, and PyPI publishing with proper release automation",
          "status": "pending",
          "dependencies": [],
          "details": "**Objective**: Create GitHub Actions workflow for automated testing, building, and PyPI publishing with proper release automation\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/integration/test_release_pipeline.py`\n   - Test `validate_release_process()` and `test_package_build()` functions\n   - Test cases: package builds successfully, tests pass in clean environment, version tagging works, PyPI upload simulation, rollback procedures, multi-platform compatibility\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: CI/CD platform choice (GitHub Actions vs alternatives)\n   - **PAUSE FOR MANUAL APPROVAL**: Release trigger strategy (manual vs automatic on tag)\n   - **PAUSE FOR MANUAL APPROVAL**: Testing matrix (Python versions, OS combinations)\n   - **PAUSE FOR MANUAL APPROVAL**: PyPI vs TestPyPI initial release strategy\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement GitHub Actions workflow in `.github/workflows/release.yml`\n   - Create automated testing pipeline with multiple Python versions and OS\n   - Set up PyPI publishing with proper secrets and authentication\n   - Create release automation scripts and rollback procedures\n   - Handle all error cases identified in tests\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create release-process.md with CI/CD documentation and contributor guidelines\n     2. **PRD**: Update product requirements to reflect automated release capabilities\n     3. **Engineering Spec**: Update technical implementation details for CI/CD architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**"
        },
        {
          "id": "26.4",
          "title": "Installation Methods and Development Setup",
          "description": "Implement and test multiple installation methods including pip install, development setup, and MCP server deployment options",
          "status": "pending",
          "dependencies": [],
          "details": "**Objective**: Implement and test multiple installation methods including pip install, development setup, and MCP server deployment options\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/integration/test_installation_methods.py`\n   - Test `test_pip_installation()`, `test_dev_installation()`, and `test_mcp_deployment()` functions\n   - Test cases: standard pip install works, development install with editable mode, MCP server starts properly, configuration detection, dependency resolution, uninstall cleanup\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: MCP server deployment strategy (standalone, Docker, systemd service)\n   - **PAUSE FOR MANUAL APPROVAL**: Development setup complexity vs ease of use trade-offs\n   - **PAUSE FOR MANUAL APPROVAL**: Configuration file locations and discovery methods\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement installation validation scripts and MCP server deployment helpers\n   - Create development setup automation and configuration templates\n   - Set up proper package entry points and command line interfaces\n   - Create deployment documentation and configuration examples\n   - Handle all error cases identified in tests\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create deployment.md and development.md with comprehensive setup guides\n     2. **PRD**: Update product requirements to reflect deployment options and developer experience\n     3. **Engineering Spec**: Update technical implementation details for installation architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**"
        },
        {
          "id": "26.5",
          "title": "User Documentation and Getting Started Guide",
          "description": "Create comprehensive user-facing documentation including getting started guide, integration examples, and troubleshooting resources",
          "status": "pending",
          "dependencies": [],
          "details": "**Objective**: Create comprehensive user-facing documentation including getting started guide, integration examples, and troubleshooting resources\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/integration/test_user_documentation.py`\n   - Test `validate_documentation_examples()` and `test_integration_guides()` functions\n   - Test cases: getting started examples work as written, VSCode integration examples function properly, command line examples produce expected output, troubleshooting steps resolve common issues, all code snippets are valid\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Documentation structure and organization approach\n   - **PAUSE FOR MANUAL APPROVAL**: Target audience definition (developers vs end users)\n   - **PAUSE FOR MANUAL APPROVAL**: Integration example priorities (which editors/tools to focus on)\n   - **PAUSE FOR MANUAL APPROVAL**: Community support channel setup (GitHub Discussions, Discord, etc.)\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement comprehensive getting started guide with step-by-step instructions\n   - Create integration examples for VSCode, PyCharm, and command line usage\n   - Develop troubleshooting guide with common issues and solutions\n   - Set up community support infrastructure and documentation\n   - Handle all error cases identified in tests\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create getting-started.md, integrations.md, and troubleshooting.md\n     2. **PRD**: Update product requirements to reflect user experience and support capabilities\n     3. **Engineering Spec**: Update technical implementation details for documentation architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**"
        },
        {
          "id": "26.6",
          "title": "Final MVP Release and Launch Validation",
          "description": "Execute the complete MVP release process with final testing, PyPI publishing, and post-launch validation",
          "status": "pending",
          "dependencies": [],
          "details": "**Objective**: Execute the complete MVP release process with final testing, PyPI publishing, and post-launch validation\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/integration/test_mvp_release.py`\n   - Test `validate_mvp_readiness()`, `test_production_release()`, and `verify_post_launch()` functions\n   - Test cases: all features work in production environment, PyPI package installs correctly, documentation is accessible, performance meets requirements, error handling works properly, rollback procedures function if needed\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Final release version number and release notes content\n   - **PAUSE FOR MANUAL APPROVAL**: Launch timing and announcement strategy\n   - **PAUSE FOR MANUAL APPROVAL**: Post-launch monitoring and support plan\n   - **PAUSE FOR MANUAL APPROVAL**: Success criteria definition for MVP launch\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement final release checklist validation and automation\n   - Execute production PyPI release with proper version tagging\n   - Verify all installation methods work in clean environments\n   - Set up post-launch monitoring and feedback collection\n   - Handle all error cases identified in tests\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create release-notes.md and update all guides with final version information\n     2. **PRD**: Update product requirements to reflect MVP completion and next phase planning\n     3. **Engineering Spec**: Update technical implementation details for production architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**"
        },
        {
          "id": 27.6,
          "title": "Consider Journal System Architectural Improvements",
          "description": "Review and plan potential improvements to the journal system based on real-world usage experience from tasks 37 and 36",
          "details": "**Objective**: After gaining practical experience with the complete system, evaluate and plan architectural improvements for the journal system.\n\n### Key Areas to Evaluate:\n\n1. **Machine-Readable Delineation**\n   - Assess current entry separation methods (### headers, --- dividers)\n   - Consider standardizing entry format across commits and reflections\n   - Evaluate metadata block possibilities for better parsing\n   - Plan consistent delimiter strategy\n\n2. **Tags and IDs for AI Enhancement**\n   - Evaluate if AI would benefit from entry IDs for cross-referencing\n   - Consider tag system for thematic grouping (#architecture, #debugging, #breakthrough)\n   - Assess potential for relationship mapping between entries\n   - Plan metadata structure for better AI context building\n\n3. **Real-Time AI Access to Reflections**\n   - Evaluate current delayed processing (reflections visible in daily summaries)\n   - Consider real-time awareness during commit processing\n   - Assess impact on AI language pattern consistency ('colorful phrases')\n   - Plan potential hybrid approach for reflection timing\n\n### Evaluation Questions:\n- How well do current entry formats serve both human readability and AI processing?\n- What patterns emerged from AI processing that suggest structural improvements?\n- Do the timing differences between commit entries and reflections create issues?\n- Would structured metadata improve AI context understanding significantly?\n\n### Deliverables:\n- Analysis document with specific recommendations\n- Priority ranking of potential improvements\n- Implementation complexity assessment\n- Plan for future enhancement tasks if warranted\n\n**Note**: This is a consideration/planning phase, not implementation. Focus on learning from actual usage patterns to inform future decisions.\"",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 26
        }
      ]
    },
    {
      "id": 29,
      "title": "Implement MCP Info Command for Diagnostics",
      "description": "Add a new 'info' tool to the MCP server that provides diagnostic information to help users troubleshoot issues, including version, telemetry status, configuration details, and dependency availability.",
      "details": "Implement the MCP info command in `src/mcp_commit_story/server.py` with the following features:\n\n1. Create a new tool handler using the `@server.tool()` decorator:\n```python\n@server.tool()\nasync def info(request):\n    \"\"\"Return diagnostic information about the MCP server.\"\"\"\n    try:\n        # Get version from pyproject.toml\n        version = get_version_from_pyproject()\n        \n        # Get telemetry status\n        telemetry_status = get_telemetry_status()\n        \n        # Get active configuration path\n        config_path = get_active_config_path()\n        \n        # Get log file location from the logging system\n        log_file = get_log_file_location()\n        \n        # Check dependency availability\n        dependencies = {\n            \"git\": check_git_availability(),\n            \"opentelemetry\": check_opentelemetry_availability()\n        }\n        \n        # Validate configuration\n        config_validation = validate_configuration()\n        \n        return {\n            \"version\": version,\n            \"telemetry_status\": telemetry_status,\n            \"config_path\": str(config_path),\n            \"log_file\": str(log_file),\n            \"dependencies\": dependencies,\n            \"config_validation\": config_validation\n        }\n    except Exception as e:\n        logger.error(f\"Error in info command: {str(e)}\")\n        return {\"error\": str(e)}\n```\n\n2. Implement helper functions for retrieving diagnostic information:\n\n```python\ndef get_version_from_pyproject():\n    \"\"\"Extract version from pyproject.toml.\"\"\"\n    try:\n        import tomli\n        from pathlib import Path\n        \n        # Find the pyproject.toml file (traverse up from current file if needed)\n        current_dir = Path(__file__).parent\n        pyproject_path = None\n        \n        # Look up to 3 levels up for pyproject.toml\n        for i in range(4):\n            check_path = current_dir / (\"../\" * i) / \"pyproject.toml\"\n            if check_path.resolve().exists():\n                pyproject_path = check_path.resolve()\n                break\n        \n        if not pyproject_path:\n            return \"unknown\"\n        \n        with open(pyproject_path, \"rb\") as f:\n            pyproject_data = tomli.load(f)\n            \n        return pyproject_data.get(\"project\", {}).get(\"version\", \"unknown\")\n    except Exception as e:\n        logger.error(f\"Error getting version: {str(e)}\")\n        return \"unknown\"\n\ndef get_telemetry_status():\n    \"\"\"Get the current telemetry status.\"\"\"\n    # Check if telemetry is enabled in configuration\n    config = get_config()\n    return {\n        \"enabled\": config.get(\"telemetry\", {}).get(\"enabled\", False),\n        \"endpoint\": config.get(\"telemetry\", {}).get(\"endpoint\", \"\")\n    }\n\ndef get_active_config_path():\n    \"\"\"Get the path to the active configuration file.\"\"\"\n    # Return the path to the currently loaded config file\n    return get_config_path()\n\ndef get_log_file_location():\n    \"\"\"Get the path to the current log file.\"\"\"\n    # This should use the logging system implemented in Task 28\n    from mcp_commit_story.logging import get_log_file_path\n    return get_log_file_path()\n\ndef check_git_availability():\n    \"\"\"Check if git is available and return version info.\"\"\"\n    try:\n        import subprocess\n        result = subprocess.run([\"git\", \"--version\"], capture_output=True, text=True, check=True)\n        return {\n            \"available\": True,\n            \"version\": result.stdout.strip()\n        }\n    except Exception:\n        return {\n            \"available\": False,\n            \"version\": None\n        }\n\ndef check_opentelemetry_availability():\n    \"\"\"Check if OpenTelemetry is available.\"\"\"\n    try:\n        import opentelemetry\n        return {\n            \"available\": True,\n            \"version\": getattr(opentelemetry, \"__version__\", \"unknown\")\n        }\n    except ImportError:\n        return {\n            \"available\": False,\n            \"version\": None\n        }\n\ndef validate_configuration():\n    \"\"\"Validate the current configuration.\"\"\"\n    # Perform validation checks on the current configuration\n    config = get_config()\n    validation_results = {}\n    \n    # Check for required configuration sections\n    required_sections = [\"journal\", \"git\", \"server\"]\n    for section in required_sections:\n        validation_results[f\"{section}_section\"] = section in config\n    \n    # Check for required paths\n    if \"journal\" in config:\n        journal_path = Path(config[\"journal\"].get(\"path\", \"\"))\n        validation_results[\"journal_path_exists\"] = journal_path.exists()\n    \n    return validation_results\n```\n\n3. Update the MCP server documentation to include the new info command:\n```python\n# In the server documentation string\n\"\"\"\nMCP Server Tools:\n...\n- info: Returns diagnostic information about the MCP server\n\"\"\"\n```\n\n4. Ensure the info command is properly registered with the MCP server and accessible through the standard MCP protocol.",
      "testStrategy": "1. Unit tests for the info command:\n```python\ndef test_info_command():\n    \"\"\"Test that the info command returns all required fields.\"\"\"\n    # Setup mock server\n    server = MockMCPServer()\n    \n    # Call info command\n    response = server.call_tool(\"info\", {})\n    \n    # Verify all required fields are present\n    assert \"version\" in response\n    assert \"telemetry_status\" in response\n    assert \"config_path\" in response\n    assert \"log_file\" in response\n    assert \"dependencies\" in response\n    assert \"config_validation\" in response\n    \n    # Verify dependencies contains required checks\n    assert \"git\" in response[\"dependencies\"]\n    assert \"opentelemetry\" in response[\"dependencies\"]\n\ndef test_version_from_pyproject():\n    \"\"\"Test that version is dynamically read from pyproject.toml.\"\"\"\n    # Create a temporary pyproject.toml with a known version\n    with tempfile.TemporaryDirectory() as tmpdir:\n        temp_path = Path(tmpdir) / \"pyproject.toml\"\n        with open(temp_path, \"w\") as f:\n            f.write('[project]\\nversion = \"1.2.3\"\\n')\n        \n        # Mock the file resolution to return our temporary file\n        with patch(\"pathlib.Path.resolve\", return_value=temp_path):\n            with patch(\"pathlib.Path.exists\", return_value=True):\n                version = get_version_from_pyproject()\n                assert version == \"1.2.3\"\n\ndef test_info_with_various_configs():\n    \"\"\"Test info command with various configuration states.\"\"\"\n    # Test with missing configuration\n    with patch(\"mcp_commit_story.server.get_config\", return_value={}):\n        response = server.call_tool(\"info\", {})\n        assert response[\"config_validation\"][\"journal_section\"] is False\n    \n    # Test with valid configuration\n    valid_config = {\n        \"journal\": {\"path\": \"/tmp/journal\"},\n        \"git\": {\"repo_path\": \"/tmp/repo\"},\n        \"server\": {\"port\": 8000}\n    }\n    with patch(\"mcp_commit_story.server.get_config\", return_value=valid_config):\n        with patch(\"pathlib.Path.exists\", return_value=True):\n            response = server.call_tool(\"info\", {})\n            assert response[\"config_validation\"][\"journal_section\"] is True\n            assert response[\"config_validation\"][\"journal_path_exists\"] is True\n\ndef test_info_through_mcp_protocol():\n    \"\"\"Test that info command works through the MCP protocol.\"\"\"\n    # Start a real MCP server\n    server_process = start_test_server()\n    try:\n        # Connect to the server using the MCP client\n        client = MCPClient(\"localhost\", 8000)\n        \n        # Call the info command\n        response = client.call(\"info\", {})\n        \n        # Verify response\n        assert \"version\" in response\n        assert \"telemetry_status\" in response\n        assert \"config_path\" in response\n        assert \"log_file\" in response\n    finally:\n        # Clean up\n        server_process.terminate()\n```\n\n2. Integration tests:\n   - Test the info command through the MCP protocol from a real client\n   - Verify that all diagnostic information is correctly reported\n   - Test with different configuration states (missing config, invalid paths, etc.)\n   - Verify that the log file location matches the actual log file being used\n\n3. Manual testing:\n   - Call the info command from the CLI client\n   - Verify that all information is displayed correctly\n   - Intentionally break dependencies (e.g., rename git executable) and verify the command correctly reports their unavailability\n   - Test with telemetry enabled and disabled to ensure correct reporting",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "Create Release Preparation Script",
      "description": "Develop an automated release validation script that performs a series of quality checks before publishing to ensure the package meets all requirements.",
      "details": "Implement a comprehensive release preparation script (`scripts/prepare_release.py`) that performs sequential validation checks before publishing:\n\n1. **Git Status Checks**:\n   ```python\n   def check_git_status():\n       \"\"\"Verify git repository is in a clean state for release\"\"\"\n       # Check current branch is main/master\n       branch = subprocess.check_output([\"git\", \"branch\", \"--show-current\"]).decode().strip()\n       if branch not in [\"main\", \"master\"]:\n           return False, f\"Not on main/master branch (current: {branch})\"\n       \n       # Check for uncommitted changes\n       status = subprocess.check_output([\"git\", \"status\", \"--porcelain\"]).decode().strip()\n       if status:\n           return False, \"Uncommitted changes detected\"\n       \n       # Check if local is in sync with remote\n       subprocess.check_call([\"git\", \"fetch\", \"origin\"])\n       local = subprocess.check_output([\"git\", \"rev-parse\", \"HEAD\"]).decode().strip()\n       remote = subprocess.check_output([\"git\", \"rev-parse\", f\"origin/{branch}\"]).decode().strip()\n       if local != remote:\n           return False, f\"Local {branch} is not in sync with origin/{branch}\"\n       \n       return True, \"Git status checks passed\"\n   ```\n\n2. **Version Checks**:\n   ```python\n   def check_version():\n       \"\"\"Verify version is consistent and not already published\"\"\"\n       # Get version from pyproject.toml\n       with open(\"pyproject.toml\", \"r\") as f:\n           pyproject = toml.load(f)\n       version = pyproject[\"project\"][\"version\"]\n       \n       # Check version format (semantic versioning)\n       if not re.match(r\"^\\d+\\.\\d+\\.\\d+$\", version):\n           return False, f\"Version {version} does not follow semantic versioning\"\n       \n       # Check if version already exists on PyPI\n       try:\n           response = requests.get(f\"https://pypi.org/pypi/mcp-commit-story/{version}/json\")\n           if response.status_code == 200:\n               return False, f\"Version {version} already exists on PyPI\"\n       except Exception as e:\n           pass  # Connection error is not a failure\n       \n       # Check version consistency across files\n       # (Add checks for other files that might contain version info)\n       \n       return True, f\"Version checks passed: {version}\"\n   ```\n\n3. **Code Quality Checks**:\n   ```python\n   def check_code_quality():\n       \"\"\"Run tests, linting, and security checks\"\"\"\n       # Run tests\n       try:\n           subprocess.check_call([\"pytest\", \"-xvs\"])\n       except subprocess.CalledProcessError:\n           return False, \"Tests failed\"\n       \n       # Run linting\n       try:\n           subprocess.check_call([\"flake8\"])\n       except subprocess.CalledProcessError:\n           return False, \"Linting failed\"\n       \n       # Run security audit\n       try:\n           subprocess.check_call([\"bandit\", \"-r\", \"src\"])\n       except subprocess.CalledProcessError:\n           return False, \"Security audit failed\"\n       \n       return True, \"Code quality checks passed\"\n   ```\n\n4. **Package Validation**:\n   ```python\n   def validate_package():\n       \"\"\"Build and validate the package\"\"\"\n       # Clean previous builds\n       if os.path.exists(\"dist\"):\n           shutil.rmtree(\"dist\")\n       \n       # Build package\n       try:\n           subprocess.check_call([\"python\", \"-m\", \"build\"])\n       except subprocess.CalledProcessError:\n           return False, \"Package build failed\"\n       \n       # Check package size\n       wheel_file = glob.glob(\"dist/*.whl\")[0]\n       size_mb = os.path.getsize(wheel_file) / (1024 * 1024)\n       if size_mb > 10:  # Example threshold\n           return False, f\"Package too large: {size_mb:.2f}MB (max 10MB)\"\n       \n       # Validate package structure\n       try:\n           subprocess.check_call([\"twine\", \"check\", \"dist/*\"])\n       except subprocess.CalledProcessError:\n           return False, \"Package validation failed\"\n       \n       return True, \"Package validation passed\"\n   ```\n\n5. **Main Script Structure**:\n   ```python\n   def main():\n       \"\"\"Run all release preparation checks\"\"\"\n       checks = [\n           (\"Git Status\", check_git_status),\n           (\"Version\", check_version),\n           (\"Code Quality\", check_code_quality),\n           (\"Package Validation\", validate_package)\n       ]\n       \n       for name, check_func in checks:\n           print(f\"Running {name} checks...\")\n           success, message = check_func()\n           if not success:\n               print(f\"âŒ {name} check failed: {message}\")\n               sys.exit(1)\n           print(f\"âœ… {message}\")\n       \n       print(\"âœ… All checks passed! Ready for release.\")\n   \n   if __name__ == \"__main__\":\n       main()\n   ```\n\n6. **Add PyProject.toml Script Entry**:\n   Update `pyproject.toml` to include:\n   ```toml\n   [project.scripts]\n   prepare-release = \"scripts.prepare_release:main\"\n   ```\n\nThe script should be designed to fail fast, stopping at the first check that fails with a clear error message. Each check should be modular and return both a success status and a message explaining the result.",
      "testStrategy": "To verify the release preparation script works correctly:\n\n1. **Test Failure Scenarios**:\n   - Create a git repository with uncommitted changes and verify the script fails with the appropriate error message\n   - Create a version that already exists on PyPI and verify the script detects this\n   - Introduce a failing test and verify the script catches it\n   - Create an invalid package structure and verify the script detects it\n\n2. **Test Error Handling**:\n   - Verify the script provides clear, actionable error messages\n   - Confirm the script exits with non-zero status code on failure\n   - Ensure the script stops at the first failure without continuing\n\n3. **Test Success Path**:\n   - Set up a clean environment that meets all requirements\n   - Run the script and verify it completes successfully\n   - Confirm all checks are executed in the correct order\n\n4. **Integration Testing**:\n   - Test the script in a CI environment to ensure it works in automated contexts\n   - Verify the script can be run via the PyProject.toml entry point\n\n5. **Specific Test Cases**:\n   ```bash\n   # Test git status check failure\n   echo \"test\" > temp.txt\n   ./scripts/prepare_release.py  # Should fail with uncommitted changes message\n   git add temp.txt\n   git commit -m \"temp commit\"\n   ./scripts/prepare_release.py  # Should fail with branch sync message\n   \n   # Test version check\n   # (modify version to match existing PyPI version)\n   ./scripts/prepare_release.py  # Should fail with version exists message\n   \n   # Test successful run\n   git checkout main\n   git pull\n   # (ensure clean state and valid version)\n   ./scripts/prepare_release.py  # Should succeed\n   ```\n\nDocument all test scenarios and expected outcomes to ensure comprehensive coverage of the script's functionality.",
      "status": "pending",
      "dependencies": [
        15,
        26
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "Refactor Large Modules for Improved Maintainability",
      "description": "Split large files into smaller, more focused modules to improve maintainability while preserving backward compatibility, following MCP best practices of keeping files under 500 lines of code.",
      "details": "This task involves refactoring large modules in the codebase to improve maintainability while ensuring backward compatibility:\n\n1. **Telemetry Module Refactoring**:\n   - Split the current telemetry.py (1800+ lines) into:\n     - `telemetry/core.py`: Core functionality and base classes\n     - `telemetry/decorators.py`: All telemetry-related decorators\n     - `telemetry/metrics.py`: Metric collection and processing\n     - `telemetry/config.py`: Configuration handling for telemetry\n   - Create appropriate `__init__.py` to re-export all public APIs\n\n2. **Journal Module Refactoring**:\n   - Split journal.py into:\n     - `journal/core.py`: Core journal functionality\n     - `journal/generators.py`: Entry generation logic\n     - `journal/serializers.py`: Serialization/deserialization logic\n   - Create appropriate `__init__.py` to re-export all public APIs\n\n3. **Backward Compatibility**:\n   - Ensure all public APIs are maintained\n   - Use `__init__.py` files to re-export all public functions and classes\n   - Example pattern:\n     ```python\n     # In telemetry/__init__.py\n     from .core import TelemetryManager, initialize_telemetry\n     from .decorators import track_usage, measure_performance\n     from .metrics import MetricCollector, send_metrics\n     from .config import TelemetryConfig, load_config\n\n     # Re-export everything to maintain the original API\n     __all__ = [\n         'TelemetryManager', 'initialize_telemetry',\n         'track_usage', 'measure_performance',\n         'MetricCollector', 'send_metrics',\n         'TelemetryConfig', 'load_config'\n     ]\n     ```\n\n4. **Update Import References**:\n   - Scan the entire codebase for imports from the original modules\n   - Update all import statements to reference the new module structure\n   - Use tools like `grep` or IDE search functionality to find all references\n\n5. **Code Organization Guidelines**:\n   - Follow single responsibility principle for each module\n   - Keep related functionality together\n   - Aim for <500 lines of code per file\n   - Add appropriate docstrings to clarify module purpose\n\n6. **Documentation Updates**:\n   - Update any documentation that references the original module structure\n   - Add module-level docstrings explaining the purpose of each new file",
      "testStrategy": "The refactoring will be verified through the following testing approach:\n\n1. **Baseline Test Execution**:\n   - Run the full test suite before starting refactoring to establish a baseline\n   - Document any existing test failures for reference\n\n2. **Incremental Testing**:\n   - Test each module after refactoring, before moving to the next\n   - Run the specific tests related to each module after refactoring\n\n3. **Full Test Suite Verification**:\n   - Run the complete test suite after all refactoring is complete\n   - Ensure all tests pass with the same results as the baseline\n\n4. **Import Compatibility Testing**:\n   - Create specific tests to verify that all public APIs are still accessible\n   - Test both direct imports and from-imports:\n     ```python\n     # Test direct imports still work\n     import telemetry\n     telemetry.initialize_telemetry()\n     \n     # Test specific imports work\n     from telemetry import initialize_telemetry\n     initialize_telemetry()\n     ```\n\n5. **Integration Testing**:\n   - Verify that components using these modules continue to function correctly\n   - Test the full application workflow to ensure no regressions\n\n6. **Manual Verification**:\n   - Manually verify that all modules are under 500 lines of code\n   - Review import statements across the codebase to ensure they've been updated\n\n7. **Documentation Testing**:\n   - Verify that documentation builds correctly with the new module structure\n   - Test any code examples in documentation to ensure they still work",
      "status": "pending",
      "dependencies": [
        26
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "Implement Parameter Parsing Leniency for MCP Handlers",
      "description": "Create a flexible parameter parsing system for MCP handlers that accepts common variations in parameter names while maintaining schema integrity.",
      "details": "This task involves implementing a parameter normalization layer to make MCP parameter parsing more flexible:\n\n1. **Parameter Normalization Layer**:\n   - Create a middleware or wrapper function that normalizes incoming parameters before they reach handler functions\n   - Implement in the core MCP request processing pipeline\n   - Design a consistent approach that works across all handlers\n\n2. **Parameter Aliasing Configuration**:\n   - Create a configuration system for parameter aliases with mappings like:\n     ```python\n     PARAMETER_ALIASES = {\n       \"path\": [\"project_path\", \"filepath\", \"file_path\"],\n       \"text\": [\"reflection\", \"content\", \"message\"],\n       \"commit_id\": [\"commit\", \"sha\", \"hash\"],\n       # Add other common variations\n     }\n     ```\n   - Ensure the configuration is extensible and documented\n\n3. **Normalization Logic**:\n   - Implement a function that transforms incoming parameters based on the alias configuration:\n     ```python\n     def normalize_parameters(params, handler_schema):\n         \"\"\"\n         Transform parameters based on aliases to match expected schema\n         while preserving original values when appropriate\n         \"\"\"\n         normalized = params.copy()\n         for expected_param, aliases in PARAMETER_ALIASES.items():\n             if expected_param not in normalized:\n                 for alias in aliases:\n                     if alias in normalized:\n                         normalized[expected_param] = normalized[alias]\n                         break\n         return normalized\n     ```\n\n4. **Schema Integrity**:\n   - Maintain strict schema advertising in API documentation\n   - Add warnings in logs when non-standard parameter names are used\n   - Consider adding deprecation notices for certain aliases to encourage standard usage\n\n5. **Integration**:\n   - Apply normalization before parameter validation\n   - Update all handler functions to use the normalized parameters\n   - Ensure backward compatibility with existing clients\n\n6. **Documentation**:\n   - Document the parameter aliasing system for developers\n   - Update API documentation to note accepted variations where appropriate",
      "testStrategy": "1. **Unit Tests for Normalization**:\n   - Create tests for the parameter normalization function with various input combinations\n   - Verify each alias correctly maps to its canonical parameter name\n   - Test edge cases like conflicting parameters or missing values\n\n2. **Handler Integration Tests**:\n   - For each MCP handler, create test cases that use alternative parameter names\n   - Verify the handler functions correctly with both standard and aliased parameters\n   - Example test cases:\n     ```python\n     def test_commit_handler_with_parameter_aliases():\n         # Test with standard parameters\n         result1 = commit_handler(path=\"/path/to/repo\", message=\"Test commit\")\n         \n         # Test with aliased parameters\n         result2 = commit_handler(project_path=\"/path/to/repo\", reflection=\"Test commit\")\n         \n         # Results should be equivalent\n         assert result1 == result2\n     ```\n\n3. **Backward Compatibility Tests**:\n   - Verify that existing code using standard parameter names continues to work\n   - Run the full test suite to ensure no regressions\n\n4. **MCP Inspector Tests**:\n   - Use the MCP inspector tool to verify parameter handling\n   - Test interactive parameter submission with various aliases\n   - Verify the inspector correctly shows normalized parameters\n\n5. **Error Handling Tests**:\n   - Test scenarios with invalid parameters to ensure proper error messages\n   - Verify that aliasing doesn't interfere with validation logic\n\n6. **Performance Tests**:\n   - Measure any performance impact from the additional normalization layer\n   - Ensure the overhead is minimal for standard parameter usage",
      "status": "pending",
      "dependencies": [
        26
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 33,
      "title": "Remove All Console Output",
      "description": "Audit and remove all remaining stdout/print statements, replacing them with proper logging and return values to ensure clean operation for MCP clients.",
      "details": "This task involves a systematic audit and cleanup of all console output in the codebase:\n\n1. **Audit Phase**:\n   - Perform a comprehensive search for all `print()` statements, `sys.stdout.write()` calls, and any other direct console output\n   - Create an inventory of all console output locations with their purpose (debug, info, error, etc.)\n   - Categorize outputs as:\n     - Debug/development outputs (to be replaced with logging)\n     - CLI user feedback (to be preserved for human users)\n     - JSON/data outputs (to be converted to return values)\n\n2. **CLI Output Refactoring**:\n   - Modify `cli.py` to properly return values instead of printing JSON:\n   ```python\n   # Before:\n   def get_entries(date_range):\n       entries = journal.get_entries(date_range)\n       print(json.dumps(entries))\n   \n   # After:\n   def get_entries(date_range):\n       entries = journal.get_entries(date_range)\n       return entries  # Click will handle JSON serialization\n   ```\n   - Preserve human-readable help text and error messages in CLI interface\n   - Implement proper exit codes for CLI operations\n\n3. **Logging Implementation**:\n   - Replace all debug/info print statements with appropriate logging calls:\n   ```python\n   # Before:\n   print(f\"Processing commit {commit_id}\")\n   \n   # After:\n   logger.debug(f\"Processing commit {commit_id}\")\n   ```\n   - Ensure all logging uses the file-based logger implemented in Task 28\n   - Add appropriate log levels (DEBUG, INFO, WARNING, ERROR) based on message importance\n\n4. **Return Value Standardization**:\n   - Ensure all functions return proper values instead of printing results\n   - Implement consistent return structures (dictionaries, objects, etc.)\n   - For functions that previously printed status updates, consider adding a callback parameter for progress reporting\n\n5. **MCP Server Cleanup**:\n   - Special focus on MCP server handlers to ensure they never write to stdout\n   - Verify all handlers return proper JSON responses rather than printing them\n   - Implement proper error handling that logs errors but returns appropriate error responses\n\n6. **Exception Handling**:\n   - Review all exception handling to ensure exceptions are logged but not printed\n   - Implement structured error responses for API functions\n\n7. **Documentation Update**:\n   - Update documentation to reflect the new logging approach\n   - Document the return value structures for all public functions",
      "testStrategy": "1. **Automated Output Capture Test**:\n   - Create a test that captures stdout during execution of all major functions\n   - Verify no unexpected output is produced\n   ```python\n   import io\n   import sys\n   from contextlib import redirect_stdout\n   \n   def test_no_stdout_output():\n       f = io.StringIO()\n       with redirect_stdout(f):\n           # Run various operations\n           client.create_entry(commit_id=\"abc123\")\n           client.generate_summary(period=\"day\")\n       \n       output = f.getvalue()\n       assert output == \"\", f\"Unexpected stdout output: {output}\"\n   ```\n\n2. **CLI Command Testing**:\n   - Test all CLI commands with various flags and options\n   - Verify help text is still displayed correctly\n   - Verify error messages are properly shown to users\n   - For commands that should return data, verify the data is correctly returned\n\n3. **Log File Verification**:\n   - Run operations that previously generated console output\n   - Verify appropriate log entries are created in the log file\n   - Check log levels are appropriate for the message content\n\n4. **MCP Client Integration Test**:\n   - Create a test MCP client that consumes the server's responses\n   - Verify the client receives proper return values and not stdout text\n   - Test error conditions to ensure they're properly communicated via return values\n\n5. **Edge Case Testing**:\n   - Test with verbose/debug flags enabled to ensure they affect logging but not stdout\n   - Test with various error conditions to verify errors are logged but not printed\n   - Test concurrent operations to ensure no race conditions in logging\n\n6. **Manual Review**:\n   - Perform a final manual code review to catch any remaining print statements\n   - Run the application with stdout redirected to a file to verify no unexpected output",
      "status": "pending",
      "dependencies": [
        26
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 36,
      "title": "Implement Cursor Chat Database Integration for Journal Context Collection",
      "description": "Enhance the journal context collection by implementing direct SQLite integration with the Cursor chat database to access complete conversation history instead of limited recent messages.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "This task involves significant improvements to the context collection system by directly accessing the Cursor chat database, implemented in five distinct phases:\n\n## Phase 0: Strategic Research\n\n1. Cursor-chat-browser Deep Analysis:\n   - Extract workspace detection algorithms from https://github.com/thomas-pedersen/cursor-chat-browser (397+ stars, battle-tested)\n   - Document their message parsing patterns and JSON structure navigation\n   - Map their cross-platform path handling (Windows/macOS/Linux/WSL2)\n   - Understand their error recovery mechanisms and permission handling\n   - Study their search/filtering patterns for boundary detection insights\n   - Analyze performance characteristics with large chat histories\n\n2. Message Completeness Validation:\n   - Confirm AI response storage locations (ensure both human AND AI messages captured)\n   - Test conversation threading and context preservation across sessions\n   - Validate timestamp accuracy, formats, and timezone handling\n   - Document metadata availability and conversation session identification\n   - Test message attribution patterns (human vs AI)\n\n3. Implementation Confidence Validation:\n   - Verify compatibility with current Cursor versions\n   - Validate support for our journal generation use cases\n   - Confirm complete message access (human + AI)\n   - Verify intelligent boundary detection capabilities\n   - Test cross-platform compatibility\n   - Document error handling patterns\n   - Understand performance characteristics\n\n## Phase 1: Core SQLite Integration (MVP)\n\n1. Remove the current limited `collect_ai_chat_context` function from `context_collection.py` that only captures recent messages.\n\n2. Add a new SQLite reader function to `context_collection.py` that can:\n   - Use Python's built-in sqlite3 module (no external dependencies)\n   - Implement multi-method workspace detection based on cursor-chat-browser patterns:\n     * Windows: %APPDATA%\\Cursor\\User\\workspaceStorage\n     * WSL2: /mnt/c/Users/<USERNAME>/AppData/Roaming/Cursor/User/workspaceStorage\n     * macOS: ~/Library/Application Support/Cursor/User/workspaceStorage\n     * Linux: ~/.config/Cursor/User/workspaceStorage\n     * Linux (remote/SSH): ~/.cursor-server/data/User/workspaceStorage\n   - Implement workspace hash discovery and validation logic\n   - Include user configuration fallback for edge cases\n   - Implement proper error handling for missing or inaccessible databases\n\n3. Implement a direct database query function that:\n   - Queries the `ItemTable` where `key='aiService.prompts'` to extract the complete conversation history\n   - Ensures both human and AI messages are captured (not just human side)\n   - Handles message threading and conversation context preservation\n   - Extracts timestamps and metadata for intelligent boundary detection\n   - Parses the returned JSON format into a structured conversation history\n   - Includes appropriate error handling and logging\n\n## Phase 2: Context Integration\n\n4. Update the downstream components in the `generate_journal_entry` functions to:\n   - Process FOUR distinct context sources: git, terminal, cursor chat database, and synthesized summary\n   - Handle cases where some context sources might be unavailable\n   - Maintain backward compatibility with existing journal generation\n\n5. Implement chat boundary detection logic:\n   - Implement smart boundary detection using complete chat history access\n   - Consider conversation breaks, topic changes, or manual delimiters\n   - Provide configurable limits with intelligent defaults based on cursor-chat-browser insights\n   - Implement topic change detection mechanisms and session separation logic\n   - Support for both automatic and manual boundary configuration\n\n## Phase 3: Enhancement Features\n\n6. Create a new synthesized summary collection function that:\n   - Uses AI prompts to generate high-level summaries of conversations\n   - Provides configuration options for summary detail level and focus areas\n   - Handles rate limiting and API errors gracefully\n\n7. Implement caching mechanisms for performance:\n   - Avoid regenerating summaries unnecessarily\n   - Optimize database query performance\n   - Implement configuration caching for performance optimization\n\n## Phase 4: Production Readiness\n\n8. Implement cross-platform support considerations:\n   - Leverage proven cursor-chat-browser patterns for cross-platform compatibility\n   - Handle path variations across operating systems (Windows/macOS/Linux/WSL2)\n   - Implement permission handling with clear error messages for database access issues\n   - Create repeatable setup for any end user's environment with auto-detection\n   - Test on Windows, macOS, and Linux\n\n9. Address packaging considerations:\n   - Zero external dependencies (using built-in sqlite3)\n   - Document installation requirements for end users\n   - Provide fallback mechanisms when database access is not available\n   - Implement robust error recovery mechanisms for corrupted/missing databases\n\n## Additional Requirements\n\n10. Add comprehensive telemetry as defined in docs/telemetry.md\n\n11. Implement user-friendly diagnostics:\n    - Check if Cursor workspace is accessible\n    - Validate chat data availability\n    - Provide helpful error messages\n    - Include troubleshooting guidance\n\n12. Update documentation to reflect the new capabilities and requirements.",
      "testStrategy": "1. Research Phase Validation:\n   - Verify cursor-chat-browser patterns work with current Cursor versions\n   - Test cross-platform path detection on all supported platforms\n   - Validate message extraction completeness (both human and AI messages)\n   - Verify boundary detection mechanisms with various conversation patterns\n   - Document performance characteristics with large chat histories\n\n2. Unit Testing:\n   - Create unit tests for the new SQLite reader function with mock database responses\n   - Test the database query function with various sample data structures\n   - Test workspace detection across different platform configurations\n   - Verify message threading and conversation context preservation\n   - Test the synthesized summary function produces expected outputs\n   - Test error handling for all new functions with various failure scenarios\n   - Verify telemetry implementation with mock events\n\n3. Integration Testing:\n   - Test the complete context collection pipeline with a real Cursor chat database\n   - Verify that all four context sources are properly integrated in journal generation\n   - Test across different operating systems to ensure path handling works correctly\n   - Verify backward compatibility with existing journal entries\n   - Test diagnostic features with various error conditions\n   - Validate boundary detection with real-world conversation patterns\n\n4. Performance Testing:\n   - Measure and optimize query performance for large chat histories\n   - Test memory usage when processing extensive conversation data\n   - Benchmark summary generation time and resource usage\n   - Verify caching mechanisms improve performance as expected\n   - Test configuration caching effectiveness\n\n5. User Acceptance Testing:\n   - Verify the quality and relevance of journal entries with the enhanced context\n   - Compare journal entries generated with and without the new context sources\n   - Gather feedback on summary quality and completeness\n   - Test user experience with diagnostic messages\n   - Validate cross-platform user experience\n\n6. Phased Implementation Verification:\n   - Verify each phase can be deployed independently\n   - Test MVP functionality in isolation\n   - Ensure enhancements build properly on core functionality\n   - Validate research findings against implementation results\n\n7. Documentation Review:\n   - Ensure all new features are properly documented\n   - Verify troubleshooting guidance is clear and helpful\n   - Confirm telemetry events are documented according to standards\n   - Document cross-platform considerations and configuration options",
      "subtasks": [
        {
          "id": 1,
          "title": "Cursor-chat-browser Analysis and Workspace Detection Research",
          "description": "Conduct deep analysis of cursor-chat-browser repository to understand workspace detection algorithms, message parsing patterns, and cross-platform path handling.",
          "details": "Research the cursor-chat-browser repository (https://github.com/thomas-pedersen/cursor-chat-browser) to extract workspace detection algorithms and understand how they handle different platforms. Document message parsing patterns, JSON structure navigation, cross-platform path handling (Windows/macOS/Linux/WSL2), error recovery mechanisms, and permission handling. Study search/filtering patterns for boundary detection insights and analyze performance characteristics with large chat histories. Validate compatibility with current Cursor versions and document findings for implementation. This is a research phase with no TDD cycle required.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 36
        },
        {
          "id": 2,
          "title": "Remove Current Chat Context Function and Design SQLite Reader",
          "description": "Remove the limited current chat collection function and design the new SQLite-based approach with proper workspace detection.",
          "details": "Remove the current limited `collect_ai_chat_context` function from `context_collection.py`. Create a new SQLite reader function that uses Python's built-in sqlite3 module. Implement multi-method workspace detection based on cursor-chat-browser patterns for Windows, WSL2, macOS, Linux, and Linux remote/SSH environments. Implement workspace hash discovery and validation logic. Include user configuration fallback for edge cases and proper error handling for missing or inaccessible databases. REQUIRES APPROVAL FOR: workspace fallback strategy, detection priority order, and user configuration methods.",
          "status": "pending",
          "dependencies": [
            "36.1"
          ],
          "parentTaskId": 36
        },
        {
          "id": 3,
          "title": "Implement Direct Database Query Function",
          "description": "Create a function to query the Cursor chat database and extract complete conversation history with proper parsing and error handling.",
          "details": "Implement a direct database query function that queries the `ItemTable` where `key='aiService.prompts'` to extract the complete conversation history. Ensure both human and AI messages are captured. Handle message threading and conversation context preservation. Extract timestamps and metadata for intelligent boundary detection. Parse the returned JSON format into a structured conversation history. Include appropriate error handling and logging. REQUIRES APPROVAL FOR: chat boundary detection strategy, message attribution handling, and message caching approach.",
          "status": "pending",
          "dependencies": [
            "36.2"
          ],
          "parentTaskId": 36
        },
        {
          "id": 4,
          "title": "Implement Chat Boundary Detection Logic",
          "description": "Create intelligent boundary detection for chat context using complete conversation history access with configurable limits and topic change detection.",
          "details": "Implement smart boundary detection using complete chat history access. Consider conversation breaks, topic changes, and manual delimiters. Provide configurable limits with intelligent defaults based on cursor-chat-browser insights. Implement topic change detection mechanisms and session separation logic. Support both automatic and manual boundary configuration. REQUIRES APPROVAL FOR: topic change detection method, default boundary limits, and edge case handling.",
          "status": "pending",
          "dependencies": [
            "36.3"
          ],
          "parentTaskId": 36
        },
        {
          "id": 5,
          "title": "Update Four-Source Context Integration",
          "description": "Update downstream components to process four distinct context sources (git, terminal, cursor chat database, synthesized summary) with proper fallback handling.",
          "details": "Update the downstream components in the `generate_journal_entry` functions to process four distinct context sources: git, terminal, cursor chat database, and synthesized summary. Handle cases where some context sources might be unavailable. Maintain backward compatibility with existing journal generation. REQUIRES APPROVAL FOR: context source prioritization, integration approach (modify existing vs new functions), and fallback behavior when Cursor database unavailable.",
          "status": "pending",
          "dependencies": [
            "36.4"
          ],
          "parentTaskId": 36
        },
        {
          "id": 6,
          "title": "Implement Synthesized Summary Collection",
          "description": "Create a new synthesized summary collection function that uses AI prompts to generate high-level summaries of conversations with configurable options.",
          "details": "Create a new synthesized summary collection function that uses AI prompts to generate high-level summaries of conversations. Provide configuration options for summary detail level and focus areas. Handle rate limiting and API errors gracefully. REQUIRES APPROVAL FOR: AI model selection and configuration, summary prompt structure for journal relevance, and configuration options (length, detail, focus areas).",
          "status": "pending",
          "dependencies": [
            "36.5"
          ],
          "parentTaskId": 36
        },
        {
          "id": 7,
          "title": "Add Performance Caching Mechanisms",
          "description": "Implement caching mechanisms to avoid regenerating summaries unnecessarily and optimize database query performance with configuration caching.",
          "details": "Implement caching mechanisms to avoid regenerating summaries unnecessarily and optimize database query performance. Implement configuration caching for performance optimization. Add cache invalidation logic for data freshness. Add memory usage monitoring and cache size limits. No approval required for this implementation-focused subtask.",
          "status": "pending",
          "dependencies": [
            "36.6"
          ],
          "parentTaskId": 36
        },
        {
          "id": 8,
          "title": "Implement Cross-Platform Support and Error Handling",
          "description": "Leverage cursor-chat-browser patterns for cross-platform compatibility and implement robust error handling with clear user-facing diagnostics.",
          "details": "Leverage proven cursor-chat-browser patterns for cross-platform compatibility. Handle path variations across operating systems (Windows/macOS/Linux/WSL2). Implement permission handling with clear error messages for database access issues. Create repeatable setup for any end user's environment with auto-detection. Implement robust error recovery mechanisms for corrupted/missing databases. Add user-friendly diagnostics. REQUIRES APPROVAL FOR: platform detection (auto vs manual), diagnostic information level, and edge case handling for non-standard installations.",
          "status": "pending",
          "dependencies": [
            "36.7"
          ],
          "parentTaskId": 36
        },
        {
          "id": 9,
          "title": "Add Comprehensive Telemetry and Final Documentation",
          "description": "Implement comprehensive telemetry as defined in docs/telemetry.md and create final documentation for the complete Cursor chat database integration system.",
          "details": "Add comprehensive telemetry as defined in docs/telemetry.md for workspace detection, database queries, summary generation, and error conditions. Ensure privacy compliance for chat data telemetry. Update all new functions with appropriate telemetry decorators. Create comprehensive user guide and update PRD/Engineering Spec with complete documentation. REQUIRES APPROVAL FOR: telemetry data collection scope and chat data privacy handling approach.",
          "status": "pending",
          "dependencies": [
            "36.8"
          ],
          "parentTaskId": 36
        }
      ]
    },
    {
      "id": 37,
      "title": "Implement File Watcher Pattern for MCP Tool Signaling in Git Hook Worker",
      "description": "Replace the placeholder call_mcp_tool() function in git_hook_worker.py with a file-based signaling mechanism that allows AI clients to autonomously discover and execute MCP tools for journal generation. Additionally, implement the MCP server entry point in __main__.py to support the python -m mcp_commit_story command.",
      "status": "pending",
      "dependencies": [
        13,
        29
      ],
      "priority": "high",
      "details": "This task involves implementing a file-based signaling mechanism in the git hook worker to enable AI clients to discover and execute MCP tools, as well as creating a properly instrumented __main__.py file:\n\n1. **Update Signal Directory Structure**:\n   - Create a function to ensure the `.mcp-commit-story/signals/` directory exists:\n   ```python\n   def ensure_signal_directory():\n       \"\"\"Create the signals directory if it doesn't exist.\"\"\"\n       signal_dir = Path(\".mcp-commit-story/signals\")\n       signal_dir.mkdir(parents=True, exist_ok=True)\n       return signal_dir\n   ```\n\n2. **Signal File Creation**:\n   - Replace the placeholder `call_mcp_tool()` function with signal file creation:\n   ```python\n   def create_signal_file(commit_info, tool_request):\n       \"\"\"Create a signal file for AI clients to discover.\"\"\"\n       metrics = get_mcp_metrics()\n       \n       try:\n           signal_dir = ensure_signal_directory()\n           \n           # Generate unique signal file name with timestamp and commit hash\n           timestamp = int(time.time())\n           signal_file = signal_dir / f\"{timestamp}_{commit_info['hash'][:8]}.json\"\n           \n           # Prepare signal content\n           signal_data = {\n               \"commit\": commit_info,\n               \"tool_request\": tool_request,\n               \"created_at\": timestamp\n           }\n           \n           # Write signal file\n           with open(signal_file, \"w\") as f:\n               json.dump(signal_data, f, indent=2)\n               \n           metrics.record_counter(\"signal_file_created\", 1)\n           logger.info(f\"Created signal file: {signal_file}\")\n           return signal_file\n       except Exception as e:\n           metrics.record_counter(\"signal_file_creation_error\", 1)\n           logger.error(f\"Failed to create signal file: {str(e)}\")\n           # Graceful degradation - never block git operations\n           return None\n   ```\n\n3. **Update Git Hook Worker**:\n   - Modify the main worker function to use the new signal mechanism:\n   ```python\n   def process_commit(repo_path, commit_hash):\n       \"\"\"Process a commit and create signal files for AI clients.\"\"\"\n       metrics = get_mcp_metrics()\n       metrics.record_counter(\"commit_processed\", 1)\n       \n       try:\n           # Get commit information\n           commit_info = get_commit_info(repo_path, commit_hash)\n           \n           # Create signal for journal entry generation\n           create_signal_file(commit_info, {\n               \"tool\": \"journal/generate\",\n               \"params\": {\n                   \"commit_hash\": commit_hash,\n                   \"repo_path\": repo_path\n               }\n           })\n           \n           # Success - return without blocking git\n           return True\n       except Exception as e:\n           metrics.record_counter(\"commit_processing_error\", 1)\n           logger.error(f\"Error processing commit: {str(e)}\")\n           # Graceful degradation - never block git operations\n           return False\n   ```\n\n4. **Signal Format Documentation**:\n   - Add documentation for the signal file format:\n   ```python\n   \"\"\"\n   Signal File Format:\n   {\n       \"commit\": {\n           \"hash\": \"full_commit_hash\",\n           \"short_hash\": \"short_hash\",\n           \"author\": \"Author Name <email@example.com>\",\n           \"message\": \"Commit message\",\n           \"timestamp\": 1234567890\n       },\n       \"tool_request\": {\n           \"tool\": \"journal/generate\",\n           \"params\": {\n               \"commit_hash\": \"full_commit_hash\",\n               \"repo_path\": \"/path/to/repo\"\n           }\n       },\n       \"created_at\": 1234567890\n   }\n   \"\"\"\n   ```\n\n5. **Telemetry Integration**:\n   - Ensure comprehensive telemetry using existing patterns:\n   ```python\n   # Add these metrics to the existing telemetry\n   metrics.record_counter(\"signal_file_created\", 1)\n   metrics.record_counter(\"signal_file_creation_error\", 1)\n   metrics.record_gauge(\"signal_file_size_bytes\", os.path.getsize(signal_file))\n   ```\n\n6. **Error Handling**:\n   - Implement robust error handling to ensure git operations are never blocked:\n   ```python\n   try:\n       # Signal creation logic\n   except Exception as e:\n       metrics.record_counter(\"signal_file_creation_error\", 1)\n       logger.error(f\"Failed to create signal file: {str(e)}\")\n       # Continue without blocking git operations\n   ```\n\n7. **Cleanup Mechanism**:\n   - Add a function to clean up old signal files:\n   ```python\n   def cleanup_old_signals(max_age_hours=24):\n       \"\"\"Remove signal files older than the specified age.\"\"\"\n       try:\n           signal_dir = Path(\".mcp-commit-story/signals\")\n           if not signal_dir.exists():\n               return\n               \n           current_time = time.time()\n           max_age_seconds = max_age_hours * 3600\n           \n           for signal_file in signal_dir.glob(\"*.json\"):\n               file_age = current_time - signal_file.stat().st_mtime\n               if file_age > max_age_seconds:\n                   signal_file.unlink()\n                   logger.debug(f\"Removed old signal file: {signal_file}\")\n       except Exception as e:\n           logger.error(f\"Error cleaning up signal files: {str(e)}\")\n   ```\n\n8. **MCP Server Entry Point Implementation**:\n   - Create `src/mcp_commit_story/__main__.py` as the official entry point:\n   ```python\n   #!/usr/bin/env python3\n   \"\"\"MCP Commit Story Server Entry Point.\n\n   This module serves as the entry point for the MCP server when invoked via:\n   `python -m mcp_commit_story`\n   \n   It initializes the MCP server with stdio transport, loads configuration,\n   and provides proper error handling and telemetry.\n   \"\"\"\n\n   import sys\n   import logging\n   import traceback\n   from typing import Optional, Dict, Any\n\n   from mcp_commit_story.config import load_config\n   from mcp_commit_story.telemetry import get_mcp_metrics, setup_telemetry\n   from mcp_commit_story.server import MCPServer\n   from mcp_commit_story.transport import StdioTransport\n\n   logger = logging.getLogger(__name__)\n\n   def main() -> int:\n       \"\"\"Initialize and run the MCP server with stdio transport.\n\n       Returns:\n           int: Exit code (0 for success, non-zero for errors)\n       \"\"\"\n       metrics = get_mcp_metrics()\n       metrics.record_counter(\"server_start_attempt\", 1)\n       \n       try:\n           # Setup logging and telemetry\n           setup_telemetry()\n           logger.info(\"Starting MCP Commit Story server\")\n           \n           # Load configuration\n           config = load_config()\n           logger.debug(f\"Loaded configuration: {config}\")\n           \n           # Initialize transport\n           transport = StdioTransport()\n           logger.info(\"Initialized stdio transport\")\n           \n           # Create and start server\n           server = MCPServer(transport=transport, config=config)\n           metrics.record_counter(\"server_started\", 1)\n           logger.info(\"MCP server initialized, starting main loop\")\n           \n           # Run server (this blocks until server exits)\n           exit_code = server.run()\n           \n           # Clean shutdown\n           metrics.record_counter(\"server_shutdown\", 1)\n           logger.info(f\"MCP server shutdown with exit code {exit_code}\")\n           return exit_code\n           \n       except KeyboardInterrupt:\n           metrics.record_counter(\"server_keyboard_interrupt\", 1)\n           logger.info(\"MCP server interrupted by user\")\n           return 130  # Standard exit code for SIGINT\n           \n       except Exception as e:\n           metrics.record_counter(\"server_startup_error\", 1)\n           logger.error(f\"Error starting MCP server: {str(e)}\")\n           logger.debug(f\"Detailed error: {traceback.format_exc()}\")\n           return 1\n\n   if __name__ == \"__main__\":\n       sys.exit(main())\n   ```\n\n9. **Server Configuration Integration**:\n   - Ensure the server loads and validates configuration:\n   ```python\n   def validate_config(config: Dict[str, Any]) -> bool:\n       \"\"\"Validate the MCP server configuration.\n\n       Args:\n           config: The configuration dictionary to validate\n\n       Returns:\n           bool: True if configuration is valid, False otherwise\n       \"\"\"\n       metrics = get_mcp_metrics()\n       \n       try:\n           # Validate required configuration keys\n           required_keys = [\"tools_path\", \"log_level\"]\n           for key in required_keys:\n               if key not in config:\n                   logger.error(f\"Missing required configuration key: {key}\")\n                   metrics.record_counter(\"config_validation_error\", 1)\n                   return False\n                   \n           # Validate tools path exists\n           tools_path = Path(config[\"tools_path\"])\n           if not tools_path.exists() or not tools_path.is_dir():\n               logger.error(f\"Tools path does not exist or is not a directory: {tools_path}\")\n               metrics.record_counter(\"config_validation_error\", 1)\n               return False\n               \n           metrics.record_counter(\"config_validation_success\", 1)\n           return True\n           \n       except Exception as e:\n           logger.error(f\"Error validating configuration: {str(e)}\")\n           metrics.record_counter(\"config_validation_error\", 1)\n           return False\n   ```",
      "testStrategy": "To verify the correct implementation of the file watcher pattern for MCP tool signaling and the MCP server entry point:\n\n1. **Unit Tests for File Watcher Pattern**:\n   - Test signal directory creation:\n   ```python\n   def test_ensure_signal_directory():\n       # Setup: Remove directory if it exists\n       signal_dir = Path(\".mcp-commit-story/signals\")\n       if signal_dir.exists():\n           shutil.rmtree(signal_dir)\n       \n       # Execute\n       result_dir = ensure_signal_directory()\n       \n       # Verify\n       assert signal_dir.exists()\n       assert result_dir == signal_dir\n   ```\n   \n   - Test signal file creation:\n   ```python\n   def test_create_signal_file():\n       # Setup\n       commit_info = {\n           \"hash\": \"abcdef1234567890\",\n           \"short_hash\": \"abcdef12\",\n           \"author\": \"Test User <test@example.com>\",\n           \"message\": \"Test commit\",\n           \"timestamp\": 1234567890\n       }\n       tool_request = {\n           \"tool\": \"journal/generate\",\n           \"params\": {\n               \"commit_hash\": \"abcdef1234567890\",\n               \"repo_path\": \"/path/to/repo\"\n           }\n       }\n       \n       # Execute\n       signal_file = create_signal_file(commit_info, tool_request)\n       \n       # Verify\n       assert signal_file.exists()\n       with open(signal_file, \"r\") as f:\n           data = json.load(f)\n           assert data[\"commit\"] == commit_info\n           assert data[\"tool_request\"] == tool_request\n           assert \"created_at\" in data\n   ```\n   \n   - Test error handling:\n   ```python\n   def test_create_signal_file_error_handling(monkeypatch):\n       # Setup: Mock json.dump to raise an exception\n       def mock_json_dump(*args, **kwargs):\n           raise IOError(\"Simulated error\")\n       \n       monkeypatch.setattr(json, \"dump\", mock_json_dump)\n       \n       # Execute\n       result = create_signal_file({\"hash\": \"test\"}, {\"tool\": \"test\"})\n       \n       # Verify: Should return None but not raise exception\n       assert result is None\n   ```\n\n2. **Unit Tests for MCP Server Entry Point**:\n   - Test main function execution:\n   ```python\n   def test_main_function(monkeypatch):\n       # Setup: Mock dependencies\n       mock_server = MagicMock()\n       mock_server.run.return_value = 0\n       \n       mock_server_class = MagicMock(return_value=mock_server)\n       monkeypatch.setattr(\"mcp_commit_story.server.MCPServer\", mock_server_class)\n       \n       mock_transport = MagicMock()\n       monkeypatch.setattr(\"mcp_commit_story.transport.StdioTransport\", \n                          lambda: mock_transport)\n       \n       mock_config = {\"tools_path\": \"/path/to/tools\", \"log_level\": \"INFO\"}\n       monkeypatch.setattr(\"mcp_commit_story.config.load_config\", \n                          lambda: mock_config)\n       \n       # Execute\n       exit_code = main()\n       \n       # Verify\n       assert exit_code == 0\n       mock_server_class.assert_called_once_with(\n           transport=mock_transport, config=mock_config)\n       mock_server.run.assert_called_once()\n   ```\n   \n   - Test error handling in main function:\n   ```python\n   def test_main_function_error_handling(monkeypatch):\n       # Setup: Mock server to raise exception\n       def mock_server_constructor(*args, **kwargs):\n           raise ValueError(\"Test error\")\n       \n       monkeypatch.setattr(\"mcp_commit_story.server.MCPServer\", \n                          mock_server_constructor)\n       \n       # Execute\n       exit_code = main()\n       \n       # Verify\n       assert exit_code == 1  # Should return error code\n   ```\n   \n   - Test configuration validation:\n   ```python\n   def test_validate_config():\n       # Valid config\n       valid_config = {\n           \"tools_path\": \".\",  # Current directory exists\n           \"log_level\": \"INFO\"\n       }\n       assert validate_config(valid_config) is True\n       \n       # Invalid config - missing key\n       invalid_config = {\"log_level\": \"INFO\"}\n       assert validate_config(invalid_config) is False\n       \n       # Invalid config - non-existent path\n       invalid_path_config = {\n           \"tools_path\": \"/path/that/does/not/exist\",\n           \"log_level\": \"INFO\"\n       }\n       assert validate_config(invalid_path_config) is False\n   ```\n\n3. **Integration Tests**:\n   - Test end-to-end git hook workflow:\n   ```python\n   def test_git_hook_workflow():\n       # Setup: Create a test git repository\n       repo_dir = Path(\"test_repo\")\n       if repo_dir.exists():\n           shutil.rmtree(repo_dir)\n       repo_dir.mkdir()\n       \n       # Initialize git repo and create a commit\n       subprocess.run([\"git\", \"init\"], cwd=repo_dir)\n       (repo_dir / \"test.txt\").write_text(\"test content\")\n       subprocess.run([\"git\", \"add\", \"test.txt\"], cwd=repo_dir)\n       subprocess.run([\"git\", \"config\", \"user.name\", \"Test User\"], cwd=repo_dir)\n       subprocess.run([\"git\", \"config\", \"user.email\", \"test@example.com\"], cwd=repo_dir)\n       subprocess.run([\"git\", \"commit\", \"-m\", \"Test commit\"], cwd=repo_dir)\n       \n       # Get commit hash\n       result = subprocess.run(\n           [\"git\", \"rev-parse\", \"HEAD\"], \n           cwd=repo_dir, \n           capture_output=True, \n           text=True\n       )\n       commit_hash = result.stdout.strip()\n       \n       # Execute\n       process_commit(str(repo_dir.absolute()), commit_hash)\n       \n       # Verify\n       signal_dir = repo_dir / \".mcp-commit-story\" / \"signals\"\n       assert signal_dir.exists()\n       \n       signal_files = list(signal_dir.glob(\"*.json\"))\n       assert len(signal_files) > 0\n       \n       with open(signal_files[0], \"r\") as f:\n           data = json.load(f)\n           assert data[\"commit\"][\"hash\"] == commit_hash\n           assert data[\"tool_request\"][\"tool\"] == \"journal/generate\"\n   ```\n   \n   - Test MCP server startup and communication:\n   ```python\n   def test_mcp_server_startup():\n       # Setup: Create mock stdin/stdout for testing\n       mock_stdin = io.StringIO('{\"jsonrpc\": \"2.0\", \"method\": \"ping\", \"id\": 1}\\n')\n       mock_stdout = io.StringIO()\n       \n       # Patch sys.stdin and sys.stdout\n       with patch(\"sys.stdin\", mock_stdin), patch(\"sys.stdout\", mock_stdout):\n           # Create a server that will process one message and exit\n           transport = StdioTransport()\n           server = MCPServer(transport=transport, config={\"tools_path\": \".\"})  \n           \n           # Run the server (it should process one message and return)\n           server.run(test_mode=True)  # Assuming test_mode makes it exit after one message\n           \n           # Verify response\n           response = mock_stdout.getvalue()\n           assert \"jsonrpc\" in response\n           assert \"result\" in response\n           assert \"id\": 1 in response\n   ```\n\n4. **Telemetry Validation**:\n   - Test telemetry recording for file watcher:\n   ```python\n   def test_file_watcher_telemetry(monkeypatch):\n       # Setup: Mock metrics\n       recorded_metrics = {}\n       \n       class MockMetrics:\n           def record_counter(self, name, value):\n               recorded_metrics[name] = recorded_metrics.get(name, 0) + value\n               \n           def record_gauge(self, name, value):\n               recorded_metrics[name] = value\n       \n       monkeypatch.setattr(\"mcp_commit_story.git_hook_worker.get_mcp_metrics\", \n                          lambda: MockMetrics())\n       \n       # Execute\n       commit_info = {\"hash\": \"test1234\"}\n       tool_request = {\"tool\": \"test\"}\n       create_signal_file(commit_info, tool_request)\n       \n       # Verify\n       assert \"signal_file_created\" in recorded_metrics\n       assert recorded_metrics[\"signal_file_created\"] == 1\n   ```\n   \n   - Test telemetry recording for server entry point:\n   ```python\n   def test_server_telemetry(monkeypatch):\n       # Setup: Mock metrics\n       recorded_metrics = {}\n       \n       class MockMetrics:\n           def record_counter(self, name, value):\n               recorded_metrics[name] = recorded_metrics.get(name, 0) + value\n       \n       monkeypatch.setattr(\"mcp_commit_story.__main__.get_mcp_metrics\", \n                          lambda: MockMetrics())\n       \n       # Mock dependencies to avoid actual server startup\n       mock_server = MagicMock()\n       mock_server.run.return_value = 0\n       monkeypatch.setattr(\"mcp_commit_story.server.MCPServer\", \n                          lambda **kwargs: mock_server)\n       \n       # Execute\n       main()\n       \n       # Verify\n       assert \"server_start_attempt\" in recorded_metrics\n       assert \"server_started\" in recorded_metrics\n       assert \"server_shutdown\" in recorded_metrics\n   ```\n\n5. **Error Handling Verification**:\n   - Test graceful degradation for file watcher:\n   ```python\n   def test_file_watcher_graceful_degradation():\n       # Setup: Create a read-only directory to cause permission error\n       signal_dir = Path(\"read_only_dir\")\n       if signal_dir.exists():\n           shutil.rmtree(signal_dir)\n       signal_dir.mkdir()\n       os.chmod(signal_dir, 0o444)  # Read-only\n       \n       # Monkeypatch the signal directory path\n       with patch(\"mcp_commit_story.git_hook_worker.ensure_signal_directory\", \n                 return_value=signal_dir):\n           # Execute\n           result = create_signal_file({\"hash\": \"test\"}, {\"tool\": \"test\"})\n           \n           # Verify: Should return None but not raise exception\n           assert result is None\n       \n       # Cleanup\n       os.chmod(signal_dir, 0o777)  # Restore permissions for cleanup\n       shutil.rmtree(signal_dir)\n   ```\n   \n   - Test server error handling:\n   ```python\n   def test_server_error_handling(monkeypatch):\n       # Setup: Force an exception during server startup\n       def mock_setup_that_fails():\n           raise RuntimeError(\"Simulated startup failure\")\n       \n       monkeypatch.setattr(\"mcp_commit_story.telemetry.setup_telemetry\", \n                          mock_setup_that_fails)\n       \n       # Execute\n       exit_code = main()\n       \n       # Verify\n       assert exit_code != 0  # Should return non-zero exit code\n   ```\n\n6. **Manual Testing**:\n   - Install the updated package in a real repository\n   - Make commits and verify signal files are created\n   - Check that AI clients can discover and process the signals\n   - Verify git operations remain fast and unblocked even if signal creation fails\n   - Test the MCP server by running `python -m mcp_commit_story` and verifying it starts correctly\n   - Test integration with Cursor by configuring `.cursor/mcp.json` to use the package",
      "subtasks": [
        {
          "id": 1,
          "title": "Create MCP Server Entry Point with Comprehensive Telemetry",
          "description": "Implement properly instrumented src/mcp_commit_story/__main__.py as the official entry point for python -m mcp_commit_story command used in .cursor/mcp.json configuration.",
          "details": "**Objective**: Implement properly instrumented `src/mcp_commit_story/__main__.py` as the official entry point for `python -m mcp_commit_story` command used in `.cursor/mcp.json` configuration.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_mcp_server_entry_point.py`\n   - Test `main()` function with successful server startup and shutdown\n   - Test `validate_server_config()` function for configuration validation\n   - Test `setup_server_telemetry()` function for telemetry initialization\n   - Test cases: successful startup with valid config, startup failure with invalid config, graceful shutdown handling, telemetry recording for all server events, exit code validation, keyboard interrupt handling\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Server initialization approach (FastMCP vs custom implementation)\n   - **PAUSE FOR MANUAL APPROVAL**: Exit code strategy for different failure scenarios\n   - **PAUSE FOR MANUAL APPROVAL**: Telemetry failure handling (continue vs abort server startup)\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement `main()` function with stdio transport initialization\n   - Create server configuration validation with comprehensive error messages\n   - Set up telemetry integration using existing MCPMetrics patterns\n   - Add graceful shutdown handling for SIGINT and other signals\n   - Implement proper exit codes following Unix conventions\n   - Add comprehensive logging for startup, shutdown, and error scenarios\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update deployment.md with MCP server entry point documentation\n     2. **PRD**: Update product requirements to reflect MCP server startup capabilities\n     3. **Engineering Spec**: Update technical implementation details for server architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**",
          "status": "in-progress",
          "dependencies": [],
          "parentTaskId": 37
        },
        {
          "id": 2,
          "title": "Implement Signal Directory Management and File Creation",
          "description": "Create signal directory structure and file-based signaling mechanism using generic create_tool_signal() function for any MCP tool.",
          "details": "**Objective**: Create signal directory structure and file-based signaling mechanism using generic `create_tool_signal()` function for any MCP tool.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_signal_file_management.py`\n   - Test `ensure_signal_directory()` function for directory creation and validation\n   - Test `create_signal_file()` function for generic signal file generation\n   - Test `validate_signal_format()` function for JSON structure validation\n   - Test cases: successful directory creation, permission errors with graceful degradation, signal file creation with proper metadata, invalid JSON handling, disk space errors, generic tool signal format validation\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Signal metadata scope (how much commit context to include)\n   - **PAUSE FOR MANUAL APPROVAL**: File naming convention for uniqueness and ordering\n   - **PAUSE FOR MANUAL APPROVAL**: JSON structure vs compressed format for readability\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement `ensure_signal_directory()` with proper path resolution and permissions\n   - Create `create_signal_file()` with unique naming, JSON formatting, and error handling\n   - Add `validate_signal_format()` for signal content validation\n   - Include comprehensive telemetry for all file operations\n   - Ensure graceful degradation never blocks git operations\n   - Add thread safety for concurrent signal creation\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create signal-format.md documenting the file-based signaling mechanism\n     2. **PRD**: Update product requirements to reflect signal-based AI integration\n     3. **Engineering Spec**: Update technical implementation details for signal architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**\n<info added on 2025-06-11T11:55:10.793Z>\n**IMPLEMENTATION COMPLETED**: Signal Directory Management and File Creation\n\n**Implementation Summary:**\n- **Module Created**: `src/mcp_commit_story/signal_management.py` (355 lines)\n- **Test Suite**: `tests/unit/test_signal_file_management.py` (545 lines, 24 tests)\n- **All 24 tests passing** with comprehensive coverage\n\n**Key Functions Implemented:**\n1. `ensure_signal_directory()` - Creates `.mcp-commit-story/signals/` structure with proper validation\n2. `create_signal_file()` - Generates unique signal files with approved design:\n   - Timestamp-based naming: `{timestamp}_{tool_name}_{hash_prefix}.json`\n   - Standard metadata scope (hash, author, date, message, files changed, stats)\n   - Pretty JSON format for readability\n   - Thread safety with locks\n   - Graceful degradation for git operations\n3. `validate_signal_format()` - JSON structure validation with required fields\n\n**Advanced Features:**\n- **Thread Safety**: `threading.Lock()` for concurrent signal creation\n- **Telemetry Integration**: Comprehensive metrics with graceful fallback when metrics unavailable\n- **Error Handling**: Custom exceptions (`SignalDirectoryError`, `SignalFileError`, `SignalValidationError`) with graceful degradation flags\n- **Filename Uniqueness**: Microsecond timestamps + collision detection with counter suffix\n- **Utility Functions**: 6 helper functions for signal management operations\n\n**Production-Ready Features:**\n- **Graceful degradation** - never blocks git operations\n- **Comprehensive telemetry** - tracks all operations and errors\n- **Thread safety** - handles concurrent git hook executions\n- **Robust error handling** - disk space, permissions, validation errors\n- **File naming strategy** - ensures chronological ordering and uniqueness\n\n**Testing Coverage:**\n- âœ… Directory creation and validation (5 tests)\n- âœ… Signal file creation and naming (8 tests) \n- âœ… JSON format validation (6 tests)\n- âœ… Integration workflows (2 tests)\n- âœ… Error handling scenarios (3 tests)\n\n**Ready for Integration**: The signal management system is fully implemented and tested, ready for use by git hooks and MCP tool discovery mechanisms in subsequent subtasks.\n</info added on 2025-06-11T11:55:10.793Z>\n<info added on 2025-06-11T12:09:51.007Z>\n**IMPLEMENTATION COMPLETED**: Signal Directory Management and File Creation\n\n**Implementation Summary:**\n- **Module Created**: `src/mcp_commit_story/signal_management.py` (355 lines)\n- **Test Suite**: `tests/unit/test_signal_file_management.py` (545 lines, 24 tests)\n- **All 24 tests passing** with comprehensive coverage\n\n**Key Functions Implemented:**\n1. `ensure_signal_directory()` - Creates `.mcp-commit-story/signals/` structure with proper validation\n2. `create_signal_file()` - Generates unique signal files with approved design:\n   - Timestamp-based naming: `{timestamp}_{tool_name}_{hash_prefix}.json`\n   - Standard metadata scope (hash, author, date, message, files changed, stats)\n   - Pretty JSON format for readability\n   - Thread safety with locks\n   - Graceful degradation for git operations\n3. `validate_signal_format()` - JSON structure validation with required fields\n\n**Advanced Features:**\n- **Thread Safety**: `threading.Lock()` for concurrent signal creation\n- **Telemetry Integration**: Comprehensive metrics with graceful fallback when metrics unavailable\n- **Error Handling**: Custom exceptions (`SignalDirectoryError`, `SignalFileError`, `SignalValidationError`) with graceful degradation flags\n- **Filename Uniqueness**: Microsecond timestamps + collision detection with counter suffix\n- **Utility Functions**: 6 helper functions for signal management operations\n\n**Production-Ready Features:**\n- **Graceful degradation** - never blocks git operations\n- **Comprehensive telemetry** - tracks all operations and errors\n- **Thread safety** - handles concurrent git hook executions\n- **Robust error handling** - disk space, permissions, validation errors\n- **File naming strategy** - ensures chronological ordering and uniqueness\n\n**Testing Coverage:**\n- âœ… Directory creation and validation (5 tests)\n- âœ… Signal file creation and naming (8 tests) \n- âœ… JSON format validation (6 tests)\n- âœ… Integration workflows (2 tests)\n- âœ… Error handling scenarios (3 tests)\n\n**Documentation Completed:**\n- Created `docs/signal-format.md` with comprehensive specification\n- Updated PRD with signal format implementation section\n- Updated engineering spec with detailed implementation documentation\n- Added reference to README.md technical documentation section\n\n**Ready for Integration**: The signal management system is fully implemented and tested, ready for use by git hooks and MCP tool discovery mechanisms in subsequent subtasks.\n</info added on 2025-06-11T12:09:51.007Z>",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 37
        },
        {
          "id": 3,
          "title": "Replace call_mcp_tool Placeholder with Generic Tool Signal Creation",
          "description": "Replace the placeholder call_mcp_tool() function with generic signal file creation logic using create_tool_signal() while maintaining all existing behavior and comprehensive telemetry.",
          "details": "**Objective**: Replace the placeholder `call_mcp_tool()` function with generic signal file creation logic using `create_tool_signal()` while maintaining all existing behavior and comprehensive telemetry.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_signal_file_replacement.py`\n   - Test `create_tool_signal()` function for generic MCP tool signal creation\n   - Test `signal_creation_telemetry()` function for metrics recording\n   - Test cases: successful signal creation for all tool types (journal_new_entry, generate_daily_summary, generate_weekly_summary), error handling with graceful degradation, telemetry recording for success and failure cases, signal content validation, parameter validation\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Should we maintain the exact same function signature as `call_mcp_tool()` for drop-in replacement or slightly modify for better signal metadata inclusion?\n   - **PAUSE FOR MANUAL APPROVAL**: How should we handle the transition period - should the old function remain as a fallback or be completely removed?\n   - **PAUSE FOR MANUAL APPROVAL**: Should signal files include additional context like terminal output or chat history hints for AI clients?\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Replace `call_mcp_tool()` function with generic signal file creation implementation\n   - Implement `create_tool_signal(tool_name: str, parameters: Dict[str, Any], commit_metadata: Dict[str, Any], repo_path: str)`:\n     * Generic signal format: `{\\\"tool\\\": tool_name, \\\"params\\\": parameters, \\\"metadata\\\": commit_metadata, \\\"created_at\\\": timestamp}`\n     * Works for any MCP tool: \\\"journal_new_entry\\\", \\\"generate_daily_summary\\\", \\\"generate_weekly_summary\\\", etc.\n     * Single implementation reduces duplication and maintenance overhead\n   - Maintain all existing function call patterns in main git hook workflow\n   - Add comprehensive telemetry for signal creation success/failure rates\n   - Ensure graceful degradation - never block git operations even if signal creation fails\n   - Include commit metadata extraction using existing git utilities\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update signal-format.md with generic tool signal documentation\n     2. **PRD**: Update product requirements to reflect generic MCP tool support\n     3. **Engineering Spec**: Update technical implementation details for generic signal architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**\n<info added on 2025-06-11T13:19:18.483Z>\nI've started implementing the TDD approach for the signal file replacement:\n\nCreated `tests/unit/test_signal_file_replacement.py` with the following test cases:\n\n1. Test `create_tool_signal()`:\n   - Successfully creates signal files for all tool types (journal_new_entry, generate_daily_summary, generate_weekly_summary)\n   - Properly formats signal JSON with tool name, parameters, commit metadata, and timestamp\n   - Creates files in the correct signal directory with proper naming convention\n   - Handles edge cases (empty parameters, missing metadata)\n\n2. Test `signal_creation_telemetry()`:\n   - Records success metrics with proper dimensions (tool type, result)\n   - Records failure metrics with error type classification\n   - Integrates with existing telemetry pipeline\n\n3. Error handling tests:\n   - Gracefully handles permission errors when creating signal files\n   - Properly manages directory creation failures\n   - Never raises exceptions that would block git operations\n\nAll tests are currently failing as expected since the implementation doesn't exist yet. This confirms we're ready to proceed with the implementation phase after getting design approvals.\n</info added on 2025-06-11T13:19:18.483Z>\n<info added on 2025-06-11T13:21:23.005Z>\n### TDD Step 1 Completed\n\nSuccessfully created comprehensive test suite in `tests/unit/test_signal_file_replacement.py` with 17 tests covering:\n\n**Test Coverage Created:**\n1. `TestCreateToolSignal` (8 tests):\n   - Signal creation for all tool types (journal_new_entry, generate_daily_summary, generate_weekly_summary)\n   - Empty parameters and missing metadata handling\n   - Naming convention compliance\n   - Thread safety with concurrent creation\n   \n2. `TestSignalCreationTelemetry` (4 tests):\n   - Success/failure metrics recording\n   - Performance metrics with duration tracking\n   - Integration with existing telemetry pipeline\n\n3. `TestErrorHandlingAndGracefulDegradation` (3 tests):\n   - Permission and disk space error handling\n   - Parameter validation\n   - Telemetry failure doesn't block operations\n\n4. `TestSignalContentValidation` (2 tests):\n   - JSON format compliance\n   - Signal structure validation\n\n**Test Results:** All 17 tests failing with ImportError (expected) - confirms TDD approach is working correctly.\n\n**Ready for Step 2:** Get design approval for function signatures, transition handling, and signal metadata before implementing the functionality.\n</info added on 2025-06-11T13:21:23.005Z>\n<info added on 2025-06-11T13:23:48.927Z>\n### STEP 2 COMPLETED: Design Approval Received\n\n**APPROVED DESIGN DECISIONS:**\n\n1. **Function Signature**: Modified signature âœ…\n   ```python\n   create_tool_signal(tool_name: str, parameters: Dict[str, Any], commit_metadata: Dict[str, Any], repo_path: str) -> Optional[str]\n   ```\n\n2. **Transition Handling**: Complete replacement âœ…\n   - Remove `call_mcp_tool()` completely \n   - Update all call sites to new signature\n   - No fallback needed (was just placeholder)\n\n3. **Signal Context**: Focused approach âœ…\n   - Include: Standard git metadata + repo context\n   - Exclude: Terminal output, chat history\n   - Keep signals focused on git events\n\n**Implementation Notes:**\n- Proceed with complete replacement of `call_mcp_tool()` function\n- Update all existing call sites to use the new function signature\n- Return value will be the path to the created signal file or None if creation failed\n- Ensure all tests are updated to reflect the approved design decisions\n</info added on 2025-06-11T13:23:48.927Z>\n<info added on 2025-06-11T13:35:19.829Z>\n### STEP 3 COMPLETE: Implementation Successfully Implemented\n\n**IMPLEMENTATION ACHIEVEMENTS:**\n\nâœ… **TDD Methodology Followed:**\n- Created 17 comprehensive tests covering all requirements\n- All tests initially failed as expected (proper TDD)\n- Implemented functionality to make tests pass\n- Final test results: 17/17 passing âœ…\n\nâœ… **Complete Replacement of `call_mcp_tool()`:**\n- Removed the placeholder `call_mcp_tool()` function entirely\n- Implemented `create_tool_signal()` with approved function signature:\n  ```python\n  create_tool_signal(tool_name: str, parameters: Dict[str, Any], commit_metadata: Dict[str, Any], repo_path: str) -> Optional[str]\n  ```\n- Added `create_tool_signal_safe()` wrapper for graceful error handling in git hooks\n- Updated all 4 call sites in `main()` function to use new signature\n\nâœ… **Generic Tool Signal Creation:**\n- Works for any MCP tool: `journal_new_entry`, `generate_daily_summary`, `generate_weekly_summary`, etc.\n- Uses existing `signal_management.py` functions for consistent signal creation\n- Maintains all existing git hook workflow behavior\n- Single implementation reduces code duplication\n\nâœ… **Comprehensive Telemetry Integration:**\n- Implemented `signal_creation_telemetry()` function with performance metrics\n- Records success/failure rates with tool-specific breakdown\n- Measures signal creation duration in milliseconds\n- Integrates with existing telemetry pipeline\n- Graceful degradation - telemetry failures never block git operations\n\nâœ… **Commit Metadata Extraction:**\n- Implemented `extract_commit_metadata()` using existing git utilities\n- Follows approved standard scope: hash, author, date, message, files_changed, stats\n- Reuses proven `get_commit_details()` function for consistency\n- Graceful fallback with minimal metadata if extraction fails\n\nâœ… **Error Handling & Validation:**\n- Parameter validation with clear error messages\n- Graceful degradation for permission/disk space errors\n- Thread-safe concurrent signal creation\n- Never blocks git operations (critical requirement met)\n\nâœ… **Integration Test Compatibility:**\n- Updated integration test mocks to use new function names\n- All 13 integration tests passing âœ…\n- Maintains backward compatibility in test behavior\n\n**DESIGN DECISIONS IMPLEMENTED:**\n- âœ… Modified function signature (better explicit interface)\n- âœ… Complete replacement approach (no fallback needed)\n- âœ… Focused signal context (git metadata only, no environmental data)\n\n**Ready for Step 4: Documentation and Final Completion**\n</info added on 2025-06-11T13:35:19.829Z>\n<info added on 2025-06-11T13:53:55.993Z>\nâœ… STEP 4 COMPLETE: Documentation and Final Verification\n\n**DOCUMENTATION UPDATES COMPLETED:**\n\nâœ… **1. Updated docs/signal-format.md:**\n- Added \"Generic Tool Signal Creation\" section documenting the new `create_tool_signal()` function\n- Documented supported tool types and benefits of generic design\n- Showed code examples for using the generic signal creation API\n- Maintained all existing information while adding comprehensive new content\n\nâœ… **2. Updated scripts/mcp-commit-story-prd.md:**\n- Added complete \"Generic MCP Tool Signal Creation\" section to Product Requirements\n- Documented universal tool support, complete placeholder replacement, enhanced interface\n- Added comprehensive telemetry, commit metadata extraction, error handling architecture\n- Included TDD implementation details and test coverage statistics\n\nâœ… **3. Engineering Spec Status:**\n- Reviewed engineering-mcp-journal-spec-final.md - no updates needed\n- Generic signal architecture integrates seamlessly with existing MCP server design\n- Table of Contents remains current and accurate\n\nâœ… **TEST SUITE VERIFICATION:**\n- **Full test suite: 757 PASSED, 22 xfailed, 0 failed âœ…**\n- **BONUS: Fixed 3 xpassed tests by removing incorrect xfail markers**\n- All integration tests passing âœ…\n- Updated legacy tests to use new function names (create_tool_signal, create_tool_signal_safe)\n- Perfect test suite with no inconsistencies or unexpected behavior\n\nâœ… **PYPROJECT.TOML VERIFICATION:**\n- Reviewed dependencies - no updates needed\n- All required packages already present and up to date\n- Build configuration remains appropriate\n\nâœ… **SUBTASK REQUIREMENTS VERIFICATION:**\n**All requirements met:**\n- âœ… TDD methodology followed (write tests â†’ fail â†’ implement â†’ pass)\n- âœ… Design approval received and implemented (modified signature, complete replacement, focused context)\n- âœ… Generic tool signal creation implemented with comprehensive telemetry\n- âœ… Complete replacement of call_mcp_tool() placeholder\n- âœ… Documentation updated in all required locations\n- âœ… Full test suite passing (757/757 passing tests)\n- âœ… No approval needed for documentation (completed directly)\n- âœ… All existing information preserved (nothing incorrect removed)\n\n**FINAL IMPLEMENTATION SUMMARY:**\n- Replaced placeholder with production-ready generic signal creation\n- Single implementation supports all MCP tools (journal_new_entry, generate_daily_summary, etc.)\n- Enhanced function signature with explicit parameters for better interface clarity\n- Complete integration with git hook workflow and existing signal management\n- Comprehensive telemetry with performance metrics and error tracking  \n- 100% backward compatibility maintained through graceful error handling\n- Zero git operation blocking - all errors handled gracefully\n\n**SUBTASK 37.3 SUCCESSFULLY COMPLETED** âœ… â™«\n</info added on 2025-06-11T13:53:55.993Z>",
          "status": "pending",
          "dependencies": [
            "37.2"
          ],
          "parentTaskId": 37
        },
        {
          "id": 4,
          "title": "Implement Signal File Cleanup and Maintenance",
          "description": "Create cleanup mechanisms and maintenance utilities for signal files with comprehensive telemetry and proper error handling.",
          "details": "**Objective**: Create cleanup mechanisms and maintenance utilities for signal files with comprehensive telemetry and proper error handling.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_signal_file_cleanup.py`\n   - Test `cleanup_old_signals()` function for age-based cleanup\n   - Test `remove_processed_signals()` function for processed signal removal\n   - Test `validate_cleanup_safety()` function for safety validation\n   - Test cases: successful cleanup of old files, safety validation prevents accidental deletion, processed signal identification and removal, disk space monitoring and cleanup triggers, concurrent cleanup operations, telemetry recording for cleanup operations\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Signal retention period (hours vs days vs configurable)\n   - **PAUSE FOR MANUAL APPROVAL**: How to mark signals as processed (separate file, database, or filename modification)\n   - **PAUSE FOR MANUAL APPROVAL**: Cleanup scheduling (on-demand vs automatic vs git hook triggered)\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement `cleanup_old_signals()` with configurable age thresholds and safety checks\n   - Create `remove_processed_signals()` with proper signal processing state tracking\n   - Add `validate_cleanup_safety()` to prevent accidental deletion of active signals\n   - Include disk space monitoring and automatic cleanup triggers\n   - Add comprehensive telemetry for cleanup operations and signal lifecycle\n   - Implement thread safety for cleanup during concurrent signal creation\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update signal-format.md with cleanup and maintenance documentation\n     2. **PRD**: Update product requirements to reflect signal lifecycle management\n     3. **Engineering Spec**: Update technical implementation details for signal maintenance and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**",
          "status": "pending",
          "dependencies": [
            "37.2"
          ],
          "parentTaskId": 37
        },
        {
          "id": 5,
          "title": "Implement Enhanced Commit Metadata Extraction",
          "description": "Create comprehensive commit metadata extraction using existing git utilities for rich signal content with file change analysis and impact assessment.",
          "details": "**Objective**: Create comprehensive commit metadata extraction using existing git utilities for rich signal content with file change analysis and impact assessment.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_commit_metadata_extraction.py`\n   - Test `extract_commit_metadata()` function for comprehensive commit information\n   - Test `analyze_file_changes()` function for file change analysis\n   - Test `assess_commit_impact()` function for impact assessment\n   - Test cases: commit message parsing and categorization, file change analysis with diff statistics, branch and remote context extraction, commit author and timestamp handling, large commit handling and summarization, merge commit detection and handling\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Commit diff content vs summaries (full diff vs statistical summary vs both)\n   - **PAUSE FOR MANUAL APPROVAL**: Large commit handling (truncation vs intelligent summarization vs full content)\n   - **PAUSE FOR MANUAL APPROVAL**: Branch and remote context inclusion (local only vs full remote tracking)\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement `extract_commit_metadata()` using existing git utilities for comprehensive information\n   - Create `analyze_file_changes()` with diff analysis, file type categorization, and change impact\n   - Add `assess_commit_impact()` for commit significance and scope assessment\n   - Include branch context, remote tracking, and merge detection\n   - Add intelligent handling of large commits with configurable thresholds\n   - Integrate with existing git utilities and error handling patterns\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update signal-format.md with metadata structure documentation\n     2. **PRD**: Update product requirements to reflect rich commit context capabilities\n     3. **Engineering Spec**: Update technical implementation details for metadata extraction and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**",
          "status": "pending",
          "dependencies": [
            "37.3"
          ],
          "parentTaskId": 37
        },
        {
          "id": 6,
          "title": "Integration Testing and End-to-End Validation",
          "description": "Create comprehensive integration tests for complete file watcher workflow with AI client simulation, error recovery validation, and performance testing.",
          "details": "**Objective**: Create comprehensive integration tests for complete file watcher workflow with AI client simulation, error recovery validation, and performance testing.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/integration/test_file_watcher_end_to_end.py`\n   - Test `test_complete_workflow()` function for full git hook to signal processing\n   - Test `simulate_ai_client_discovery()` function for AI client signal processing\n   - Test `test_error_recovery()` function for error handling and recovery\n   - Test cases: complete git commit to signal creation workflow, AI client signal discovery and processing simulation, concurrent signal creation and processing, error injection and recovery testing, performance benchmarking with large repositories, MCP server integration testing\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: AI client simulation scope (full MCP client vs simplified mock)\n   - **PAUSE FOR MANUAL APPROVAL**: MCP server testing approach (embedded vs subprocess vs mock)\n   - **PAUSE FOR MANUAL APPROVAL**: Performance benchmarks and acceptable thresholds\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement complete end-to-end workflow testing from git hook to signal processing\n   - Create AI client simulation that discovers and processes signals like a real MCP client\n   - Add comprehensive error injection and recovery validation\n   - Include performance testing with realistic repository sizes and commit frequencies\n   - Test MCP server startup and signal processing integration\n   - Add concurrent operation testing for production-like scenarios\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Create testing.md with integration test documentation and performance baselines\n     2. **PRD**: Update product requirements to reflect validated performance and reliability characteristics\n     3. **Engineering Spec**: Update technical implementation details for integration architecture and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**",
          "status": "pending",
          "dependencies": [
            "37.1",
            "37.4",
            "37.5"
          ],
          "parentTaskId": 37
        },
        {
          "id": 7,
          "title": "Research and Refactor Signal Files for Minimal State with Git Context Integration",
          "description": "Research the redundancy between signal file metadata and existing git_utils/context_collection functions, then refactor to use minimal state approach where journal entries only need commit hash for git context lookup.",
          "details": "**Objective**: Research the redundancy between signal file metadata and existing git_utils/context_collection functions, then refactor to use minimal state approach where journal entries only need commit hash for git context lookup.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_minimal_signal_state.py`\n   - Test `create_minimal_signal()` function that only stores commit hash + tool parameters\n   - Test `fetch_git_context_on_demand()` function that retrieves context using existing git_utils\n   - Test `determine_summary_trigger()` function for \"awakening the AI beast\" decision logic\n   - Test cases: minimal signal creation with only hash and tool params, on-demand git context retrieval using existing git_utils functions, summary trigger logic based on commit patterns/frequency, privacy-safe signal content (no PII), integration with existing context_collection.py functions\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: Minimal signal content scope (hash + tool + params vs additional essential metadata)\n   - **PAUSE FOR MANUAL APPROVAL**: Summary trigger mechanism (time-based vs commit-count vs content-based analysis)\n   - **PAUSE FOR MANUAL APPROVAL**: AI \"awakening\" strategy (separate signal vs flag in journal signal vs external trigger)\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Research existing git context collection in git_utils.py and context_collection.py\n   - Implement `create_minimal_signal()` that stores only: tool name, parameters, commit hash, timestamp\n   - Create `fetch_git_context_on_demand()` that uses existing git utilities for context when needed\n   - Develop \"AI beast awakening\" logic in `determine_summary_trigger()` for summary generation triggers\n   - Refactor existing signal creation to use minimal state approach\n   - Eliminate redundant git metadata storage while maintaining functionality\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update signal-format.md with minimal state architecture and privacy benefits\n     2. **PRD**: Update product requirements to reflect minimal state approach and context separation\n     3. **Engineering Spec**: Update technical implementation details for git context integration patterns and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**",
          "status": "pending",
          "dependencies": [
            "37.3"
          ],
          "parentTaskId": 37
        },
        {
          "id": 8,
          "title": "Implement Automatic .gitignore Management for Signal Files",
          "description": "Update installation/setup processes to automatically add .mcp-commit-story/ to .gitignore during git hook installation, journal initialization, and CLI setup commands to prevent accidental commit of local AI processing artifacts.",
          "details": "**Objective**: Update installation/setup processes to automatically add `.mcp-commit-story/` to `.gitignore` during git hook installation, journal initialization, and CLI setup commands to prevent accidental commit of local AI processing artifacts.\n\n### TDD Steps:\n1. **WRITE TESTS FIRST**\n   - Create `tests/unit/test_gitignore_management.py`\n   - Test `ensure_gitignore_entry()` function for adding signal directory to .gitignore\n   - Test `validate_gitignore_update()` function for .gitignore modification validation\n   - Test `gitignore_integration_hooks()` function for installation process integration\n   - Test cases: .gitignore creation when file doesn't exist, appending to existing .gitignore without duplication, handling different .gitignore formats and comments, integration with git hook installation process, integration with journal initialization process, integration with CLI setup commands\n   - **RUN TESTS - VERIFY THEY FAIL**\n\n2. **GET APPROVAL FOR DESIGN CHOICES**\n   - **PAUSE FOR MANUAL APPROVAL**: .gitignore entry format (simple directory vs pattern with comments)\n   - **PAUSE FOR MANUAL APPROVAL**: Installation integration points (which setup commands should trigger this)\n   - **PAUSE FOR MANUAL APPROVAL**: Error handling for read-only .gitignore or permission issues\n\n3. **IMPLEMENT FUNCTIONALITY**\n   - Implement `ensure_gitignore_entry()` that safely adds `.mcp-commit-story/` to .gitignore\n   - Create `validate_gitignore_update()` for checking existing entries and preventing duplicates\n   - Add integration points in git hook installation (similar to how Husky manages .husky/)\n   - Add integration points in journal initialization process\n   - Add integration points in CLI setup commands\n   - Include proper error handling for permission issues and read-only files\n   - Follow patterns from other tools (Node.js node_modules/, Python __pycache__/, etc.)\n   - **RUN TESTS - VERIFY THEY PASS**\n\n4. **DOCUMENT AND COMPLETE**\n   - Add documentation IF NEEDED in three places:\n     1. **Docs directory**: Update installation.md with automatic .gitignore management documentation\n     2. **PRD**: Update product requirements to reflect automatic privacy protection during setup\n     3. **Engineering Spec**: Update technical implementation details for .gitignore integration patterns and make sure TOC is current\n   - **Do not remove existing information unless it's incorrect**\n   - **No approval needed** - make documentation edits directly\n   - **Run the entire test suite and make sure all tests are passing**\n   - **Make sure pyproject.toml is updated as needed**\n   - Double check all subtask requirements are met before marking this subtask as complete\n   - **MARK COMPLETE**",
          "status": "pending",
          "dependencies": [
            "37.2"
          ],
          "parentTaskId": 37
        }
      ]
    }
  ]
}