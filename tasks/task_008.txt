# Task ID: 8
# Title: Implement Journal Initialization
# Status: pending
# Dependencies: 2, 3, 6, 7
# Priority: high
# Description: Create the functionality to initialize a journal in a Git repository, including directory structure and configuration.
# Details:
Implement journal initialization in both the MCP server and CLI with the following features:

1. Directory structure creation:
```python
def create_journal_structure(base_path):
    """Create journal directory structure"""
    # Create directories
    (base_path / "daily").mkdir(parents=True, exist_ok=True)
    (base_path / "summaries" / "daily").mkdir(parents=True, exist_ok=True)
    (base_path / "summaries" / "weekly").mkdir(parents=True, exist_ok=True)
    (base_path / "summaries" / "monthly").mkdir(parents=True, exist_ok=True)
    (base_path / "summaries" / "yearly").mkdir(parents=True, exist_ok=True)
    return True
```

2. Simplified configuration file generation:
```python
def generate_default_config(config_path, journal_path):
    """Generate minimal default configuration file"""
    default_config = {
        "journal": {
            "path": str(journal_path)
        },
        "git": {
            "exclude_patterns": ["journal/**"]
        },
        "telemetry": {
            "enabled": True
        }
    }
    with open(config_path, "w") as f:
        yaml.dump(default_config, f, default_flow_style=False)
    return True
```

3. Configuration handling:
```python
def setup_configuration(repo_path):
    """Set up configuration file"""
    config_path = Path(repo_path) / ".mcp-journalrc.yaml"
    example_path = Path(repo_path) / ".mcp-journalrc.yaml.example"
    journal_path = Path(repo_path) / "journal"
    
    # Check if config already exists
    if config_path.exists():
        return False, "Journal already initialized"
    
    # Check for example config and copy if exists
    if example_path.exists():
        shutil.copy(example_path, config_path)
    else:
        # Generate minimal default config
        generate_default_config(config_path, journal_path)
    
    return True, config_path
```

4. MCP handler implementation:
```python
@trace_operation("journal_init")
async def handle_init(request):
    """Handle journal/init operation"""
    repo_path = request.get("repo_path", os.getcwd())
    
    # Setup configuration
    success, result = setup_configuration(repo_path)
    if not success:
        return {"status": "error", "error": result}
    
    # Create structure
    journal_path = Path(repo_path) / "journal"
    create_journal_structure(journal_path)
    
    # Install git hook (no longer optional)
    install_post_commit_hook(repo_path)
    
    # Return success
    return {
        "status": "success",
        "message": "Journal initialized successfully",
        "paths": {
            "config": str(result),
            "journal": str(journal_path)
        }
    }
```

5. CLI command implementation:
```python
@cli.command()
@click.option("--debug", is_flag=True, help="Show debug information")
def init(debug):
    """Initialize journal in current repository"""
    try:
        # Setup configuration
        success, result = setup_configuration(Path.cwd())
        if not success:
            click.echo(result)
            return
        
        # Create structure
        journal_path = Path.cwd() / "journal"
        create_journal_structure(journal_path)
        
        # Install git hook (no longer optional)
        install_post_commit_hook(Path.cwd())
        click.echo("Git post-commit hook installed")
        
        click.echo(f"Journal initialized at {journal_path}")
    except Exception as e:
        if debug:
            click.echo(f"Error: {e}")
            traceback.print_exc()
        else:
            click.echo(f"Error: {e}")
```

# Test Strategy:
1. Unit tests for directory structure creation
2. Tests for simplified configuration file generation
3. Tests for configuration handling (existing config, example config, default generation)
4. Tests for MCP handler implementation
5. Tests for CLI command implementation
6. Tests for handling existing journal
7. Integration tests for full initialization flow
8. Tests to verify git hook installation is always performed
9. Tests to verify the minimal configuration contains only the essential settings
