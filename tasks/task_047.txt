# Task ID: 47
# Title: Implement Chat Boundary Detection Logic
# Status: pending
# Dependencies: 46
# Priority: medium
# Description: Add configurable message count limits to prevent overwhelming the AI with excessive chat history during journal generation and other operations.
# Details:
This task implements a simplified approach to manage chat history size with configurable message limits:

1. **Message Limit Function**:
```python
@trace_mcp_operation
def limit_chat_messages(chat_history: dict, max_messages: int) -> dict:
    """
    Limit the number of messages in chat history to prevent context overflow
    
    Args:
        chat_history: Dictionary containing chat history with 'messages' list
        max_messages: Maximum number of messages to keep (most recent)
        
    Returns:
        Dictionary with truncated messages list and metadata about truncation
    """
    if not chat_history or 'messages' not in chat_history:
        return chat_history
        
    messages = chat_history.get('messages', [])
    original_count = len(messages)
    
    # No truncation needed if under the limit
    if original_count <= max_messages:
        result = chat_history.copy()
        result['metadata'] = result.get('metadata', {}).copy()
        result['metadata']['truncated'] = False
        result['metadata']['removed_messages'] = 0
        return result
    
    # Keep the most recent messages up to max_messages
    truncated_messages = messages[-max_messages:]
    removed_count = original_count - len(truncated_messages)
    
    # Create result with truncation metadata
    result = chat_history.copy()
    result['messages'] = truncated_messages
    result['metadata'] = result.get('metadata', {}).copy()
    result['metadata']['truncated'] = True
    result['metadata']['removed_messages'] = removed_count
    result['metadata']['original_message_count'] = original_count
    
    return result
```

2. **Integration with Chat Collection Pipeline**:
```python
@trace_mcp_operation
def get_chat_history(max_messages=1000):
    """
    Get chat history with configurable message limits
    
    Args:
        max_messages: Maximum number of messages to include (default: 1000)
        
    Returns:
        Dictionary containing limited chat history
    """
    # Get chat history from database (already filtered to last 48 hours by Task 46.9)
    chat_history = query_cursor_chat_database()
    
    # Apply message limit
    limited_history = limit_chat_messages(chat_history, max_messages)
    
    # Log telemetry for truncation events
    if limited_history.get('metadata', {}).get('truncated', False):
        log_telemetry('chat_history_truncation', {
            'original_count': limited_history['metadata']['original_message_count'],
            'removed_count': limited_history['metadata']['removed_messages'],
            'final_count': len(limited_history['messages']),
            'max_messages': max_messages
        })
    
    return limited_history
```

3. **Configuration Options**:
```python
# Default configuration in config.py
CHAT_CONFIG = {
    'max_messages': 1000,  # Default message limit
    'enable_truncation': True,  # Whether to apply message limits
}

# Function to get configuration
def get_chat_config():
    """Get chat configuration with defaults"""
    # Load from settings or use defaults
    return CHAT_CONFIG.copy()
```

4. **Error Handling and Validation**:
```python
def validate_message_limit(max_messages):
    """Validate message limit parameter"""
    if not isinstance(max_messages, int):
        raise ValueError("max_messages must be an integer")
        
    if max_messages <= 0:
        raise ValueError("max_messages must be greater than zero")
    
    return True
```

Implementation Notes:
- This simplified approach focuses on message count limits rather than complex boundary detection
- The implementation leverages existing 48-hour filtering from Task 46.9
- Message truncation keeps the most recent messages up to the configured limit
- Metadata is added to indicate if truncation occurred and how many messages were removed
- Telemetry is implemented to track truncation events and message statistics
- The default limit of 1000 messages provides a reasonable balance between context and performance
- The AI can use its intelligence during journal generation to identify relevant content within the provided messages

# Test Strategy:
The testing strategy for the Chat Message Limiting Logic will include:

1. **Unit Tests for Message Limiting Function**:
```python
def test_limit_chat_messages_under_limit():
    """Test that messages under the limit are not truncated"""
    chat_history = {
        'messages': [{'content': f'Message {i}'} for i in range(10)]
    }
    
    result = limit_chat_messages(chat_history, 20)
    
    assert len(result['messages']) == 10
    assert result['metadata']['truncated'] == False
    assert result['metadata']['removed_messages'] == 0

def test_limit_chat_messages_over_limit():
    """Test that messages over the limit are truncated correctly"""
    chat_history = {
        'messages': [{'content': f'Message {i}'} for i in range(100)]
    }
    
    result = limit_chat_messages(chat_history, 50)
    
    assert len(result['messages']) == 50
    assert result['metadata']['truncated'] == True
    assert result['metadata']['removed_messages'] == 50
    assert result['metadata']['original_message_count'] == 100
    
    # Verify we kept the most recent messages
    assert result['messages'][0]['content'] == 'Message 50'
    assert result['messages'][-1]['content'] == 'Message 99'

def test_limit_chat_messages_empty_history():
    """Test handling of empty chat history"""
    chat_history = {'messages': []}
    result = limit_chat_messages(chat_history, 50)
    
    assert len(result['messages']) == 0
    assert result['metadata']['truncated'] == False
    assert result['metadata']['removed_messages'] == 0
    
    # Test with missing messages key
    chat_history = {}
    result = limit_chat_messages(chat_history, 50)
    assert result == {}

def test_limit_chat_messages_exact_limit():
    """Test when message count exactly matches the limit"""
    chat_history = {
        'messages': [{'content': f'Message {i}'} for i in range(50)]
    }
    
    result = limit_chat_messages(chat_history, 50)
    
    assert len(result['messages']) == 50
    assert result['metadata']['truncated'] == False
    assert result['metadata']['removed_messages'] == 0
```

2. **Integration Tests with Mock Data**:
```python
@patch('mcp.chat.query_cursor_chat_database')
def test_get_chat_history_with_limits(mock_query):
    """Test that get_chat_history correctly applies message limits"""
    # Setup mock database response
    mock_query.return_value = {
        'messages': [{'content': f'Message {i}'} for i in range(2000)]
    }
    
    # Test with default limit
    history = get_chat_history()
    assert len(history['messages']) == 1000
    assert history['metadata']['truncated'] == True
    assert history['metadata']['removed_messages'] == 1000
    
    # Test with custom limit
    history = get_chat_history(max_messages=500)
    assert len(history['messages']) == 500
    assert history['metadata']['truncated'] == True
    assert history['metadata']['removed_messages'] == 1500
```

3. **Telemetry Validation Tests**:
```python
@patch('mcp.chat.query_cursor_chat_database')
@patch('mcp.telemetry.log_telemetry')
def test_truncation_telemetry(mock_log_telemetry, mock_query):
    """Test that telemetry is correctly logged for message truncation"""
    # Setup mock database response
    mock_query.return_value = {
        'messages': [{'content': f'Message {i}'} for i in range(1500)]
    }
    
    # Get chat history with default limit (1000)
    history = get_chat_history()
    
    # Verify telemetry was logged with correct data
    mock_log_telemetry.assert_called_once()
    call_args = mock_log_telemetry.call_args[0]
    assert call_args[0] == 'chat_history_truncation'
    assert call_args[1]['original_count'] == 1500
    assert call_args[1]['removed_count'] == 500
    assert call_args[1]['final_count'] == 1000
    assert call_args[1]['max_messages'] == 1000
```

4. **Configuration Validation Tests**:
```python
def test_validate_message_limit():
    """Test validation of message limit parameter"""
    # Valid limits should pass
    assert validate_message_limit(100)
    assert validate_message_limit(1)
    
    # Invalid limits should raise appropriate errors
    with pytest.raises(ValueError, match="max_messages must be an integer"):
        validate_message_limit("100")
        
    with pytest.raises(ValueError, match="max_messages must be greater than zero"):
        validate_message_limit(0)
        
    with pytest.raises(ValueError, match="max_messages must be greater than zero"):
        validate_message_limit(-10)
```

5. **Edge Case Tests**:
```python
def test_limit_chat_messages_with_existing_metadata():
    """Test that existing metadata is preserved during truncation"""
    chat_history = {
        'messages': [{'content': f'Message {i}'} for i in range(100)],
        'metadata': {
            'source': 'test',
            'timestamp': 123456789
        }
    }
    
    result = limit_chat_messages(chat_history, 50)
    
    # Verify truncation metadata was added
    assert result['metadata']['truncated'] == True
    assert result['metadata']['removed_messages'] == 50
    
    # Verify existing metadata was preserved
    assert result['metadata']['source'] == 'test'
    assert result['metadata']['timestamp'] == 123456789
```

6. **Performance Tests**:
```python
def test_message_limiting_performance():
    """Test performance of message limiting with large message sets"""
    # Generate a large set of test messages
    chat_history = {
        'messages': [{'content': f'Message {i}', 'data': 'x' * 1000} for i in range(10000)]
    }
    
    # Measure performance
    start_time = time.time()
    result = limit_chat_messages(chat_history, 1000)
    end_time = time.time()
    
    # Verify performance is acceptable (should be under 50ms for 10000 messages)
    assert end_time - start_time < 0.05
    
    # Verify correct truncation
    assert len(result['messages']) == 1000
    assert result['metadata']['removed_messages'] == 9000
```

The test suite will be executed as part of the CI/CD pipeline to ensure the message limiting logic works correctly across different scenarios and edge cases.

# Subtasks:
## 1. Add Message Limit Function [pending]
### Dependencies: None
### Description: Create `limit_chat_messages()` function in appropriate cursor_db module. Function signature: `limit_chat_messages(chat_history: dict, max_messages: int) -> dict`. Takes chat_history dict and max_messages parameter. Returns dict with truncated messages list (keeping most recent messages). Add metadata flags indicating if truncation occurred and how many messages were removed. Include comprehensive test coverage for edge cases (empty history, limits larger than message count).
### Details:


## 2. Integration and Configuration [pending]
### Dependencies: None
### Description: Wire `limit_chat_messages()` into the chat collection pipeline. Add configuration option for max_messages with suggested default of 1000. Update relevant functions to respect message limits. Document that this is a simple safety limit, not intelligent boundary detection. Add telemetry tracking for truncation events and message count statistics.
### Details:


