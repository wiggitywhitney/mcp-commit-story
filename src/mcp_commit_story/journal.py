import re
from typing import List, Optional, Dict, Union
from pathlib import Path
import os
from mcp_commit_story.context_types import ChatHistory, TerminalContext, SummarySection, TechnicalSynopsisSection, JournalContext, AccomplishmentsSection, FrustrationsSection, ToneMoodSection, DiscussionNotesSection, TerminalCommandsSection, CommitMetadataSection
# TechnicalSynopsisSection: Represents the technical synopsis section of a journal entry.
# This section provides a code-focused analysis of what changed, generated by an AI-driven function pattern.
# The function returns a placeholder; the AI agent is expected to execute the docstring prompt and fill in the content.

"""
Journal entry generation for engineering work.

Content Quality Guidelines:
- Focus on signal (unique insights, decisions, challenges) over noise (routine procedures)
- Highlight what makes each entry unique rather than repeating standard practices
- Capture the narrative "story" behind the code changes
- Include emotional context when relevant, but only with clear supporting evidence
- Omit standard workflow details unless they're directly relevant to understanding the work
"""

class JournalParseError(Exception):
    pass

class JournalEntry:
    """
    Represents a single engineering journal entry, with Markdown serialization.
    Only non-empty sections are included in output.

    Content should prioritize unique insights and developments over routine
    workflow steps. The goal is to create entries that provide value when
    reviewed in the future, focusing on "why" and "how" rather than just "what".
    """

    def __init__(
        self,
        timestamp: str,
        commit_hash: str,
        summary: Optional[str] = None,
        technical_synopsis: Optional[str] = None,
        accomplishments: Optional[List[str]] = None,
        frustrations: Optional[List[str]] = None,
        terminal_commands: Optional[List[str]] = None,
        discussion_notes: Optional[List[Union[str, Dict[str, str]]]] = None,
        tone_mood: Optional[Dict[str, str]] = None,  # {'mood': str, 'indicators': str}
        commit_metadata: Optional[Dict[str, str]] = None,
    ):
        self.timestamp = timestamp
        self.commit_hash = commit_hash
        self.summary = summary
        self.technical_synopsis = technical_synopsis
        self.accomplishments = accomplishments or []
        self.frustrations = frustrations or []
        self.terminal_commands = terminal_commands or []
        self.discussion_notes = discussion_notes or []
        self.tone_mood = tone_mood
        self.commit_metadata = commit_metadata or {}

    def to_markdown(self) -> str:
        """
        Serialize the journal entry to Markdown with improved formatting:
        - H3 for entry header
        - H4 for section headers
        - Blank line after section headers
        - Blank line between bullet points
        - Blank line on speaker change in discussion notes
        - Terminal commands as a single bash code block
        - Blockquotes visually distinct
        - (Horizontal rule between entries is handled externally)
        """
        lines = [f"### {self.timestamp} — Commit {self.commit_hash}", ""]

        def section(header, content_lines):
            if not content_lines:
                return []
            out = [f"#### {header}", ""]
            out.extend(content_lines)
            out.append("")
            return out

        # 1. Summary
        if self.summary:
            lines += section("Summary", [self.summary])

        # 2. Technical Synopsis
        if self.technical_synopsis:
            lines += section("Technical Synopsis", [self.technical_synopsis])

        # 3. Accomplishments
        if self.accomplishments:
            acc_lines = []
            for i, item in enumerate(self.accomplishments):
                acc_lines.append(f"- {item}")
                if i < len(self.accomplishments) - 1:
                    acc_lines.append("")  # blank line between bullets
            lines += section("Accomplishments", acc_lines)

        # 4. Frustrations or Roadblocks
        if self.frustrations:
            frus_lines = []
            for i, item in enumerate(self.frustrations):
                frus_lines.append(f"- {item}")
                if i < len(self.frustrations) - 1:
                    frus_lines.append("")
            lines += section("Frustrations or Roadblocks", frus_lines)

        # 5. Tone/Mood
        if self.tone_mood and self.tone_mood.get("mood") and self.tone_mood.get("indicators"):
            tm_lines = [f"> {self.tone_mood['mood']}", f"> {self.tone_mood['indicators']}"]
            lines += section("Tone/Mood", tm_lines)

        # 6. Discussion Notes (from chat)
        if self.discussion_notes:
            dn_lines = []
            prev_speaker = None
            for note in self.discussion_notes:
                if isinstance(note, dict) and 'speaker' in note and 'text' in note:
                    speaker = note['speaker']
                    text_lines = note['text'].splitlines()
                    if prev_speaker is not None and speaker != prev_speaker:
                        dn_lines.append("")  # blank line on speaker change
                    if text_lines:
                        dn_lines.append(f"> **{speaker}:** {text_lines[0]}")
                        for l in text_lines[1:]:
                            dn_lines.append(f"> {l}")
                    else:
                        dn_lines.append(f"> **{speaker}:**")
                    prev_speaker = speaker
                else:
                    text_lines = str(note).splitlines()
                    for l in text_lines:
                        dn_lines.append(f"> {l}")
            lines += section("Discussion Notes (from chat)", dn_lines)

        # 7. Terminal Commands (AI Session)
        if self.terminal_commands:
            tc_lines = ["Commands executed by AI during this work session:", "```bash"]
            tc_lines.extend(self.terminal_commands)
            tc_lines.append("```")
            lines += section("Terminal Commands (AI Session)", tc_lines)

        # 8. Commit Metadata
        if self.commit_metadata:
            btc_lines = [f"- **{k}:** {v}" for k, v in self.commit_metadata.items()]
            lines += section("Commit Metadata", btc_lines)

        # Remove trailing blank lines
        while lines and lines[-1] == "":
            lines.pop()
        return "\n".join(lines).strip()

class JournalParser:
    @staticmethod
    def parse(md):
        if not md or not md.strip():
            raise JournalParseError('Empty entry')
        # Parse H4 (####) headers for all sections
        def extract_section(header):
            pattern = rf"#### {header}\n(.+?)(?=\n#### |\Z)"
            m = re.search(pattern, md, re.DOTALL)
            return m.group(1).strip() if m else ''
        timestamp_commit = re.search(r"###\s+(.*?) — Commit ([a-zA-Z0-9]+)", md)
        if timestamp_commit:
            timestamp = timestamp_commit.group(1)
            commit_hash = timestamp_commit.group(2)
            summary = extract_section("Summary")
            technical_synopsis = extract_section("Technical Synopsis")
            # Accomplishments
            accomplishments = []
            acc_section = extract_section("Accomplishments")
            if acc_section:
                accomplishments = [line[2:].strip() for line in acc_section.splitlines() if line.startswith('- ')]
            # Frustrations
            frustrations = []
            frus_section = extract_section("Frustrations or Roadblocks")
            if frus_section:
                frustrations = [line[2:].strip() for line in frus_section.splitlines() if line.startswith('- ')]
            # Tone/Mood
            tone_mood = None
            tm_section = extract_section("Tone/Mood")
            if tm_section:
                tm_lines = [l.strip('> ').strip() for l in tm_section.splitlines() if l.strip().startswith('>')]
                if len(tm_lines) >= 2:
                    tone_mood = {"mood": tm_lines[0], "indicators": tm_lines[1]}
            # Discussion Notes
            discussion_notes = []
            dn_section = extract_section("Discussion Notes (from chat)")
            if dn_section:
                for l in dn_section.splitlines():
                    l = l.strip()
                    if l.startswith('> **'):
                        # Speaker-attributed
                        m = re.match(r'> \*\*(.+?):\*\* (.+)', l)
                        if m:
                            discussion_notes.append({"speaker": m.group(1), "text": m.group(2)})
                    elif l.startswith('> '):
                        discussion_notes.append(l[2:])
            # Terminal Commands
            terminal_commands = []
            tc_section = extract_section("Terminal Commands (AI Session)")
            if tc_section:
                in_block = False
                for l in tc_section.splitlines():
                    if l.strip() == '```bash':
                        in_block = True
                        continue
                    if l.strip() == '```':
                        in_block = False
                        continue
                    if in_block:
                        terminal_commands.append(l)
            # Commit Metadata
            commit_metadata = {}
            cm_section = extract_section("Commit Metadata")
            if cm_section:
                for l in cm_section.splitlines():
                    l = l.strip()
                    if l.startswith('- **') and ':** ' in l:
                        k, v = l[4:].split(':** ', 1)
                        commit_metadata[k.strip()] = v.strip()
            return JournalEntry(
                timestamp=timestamp,
                commit_hash=commit_hash,
                summary=summary,
                technical_synopsis=technical_synopsis,
                accomplishments=accomplishments,
                frustrations=frustrations,
                tone_mood=tone_mood,
                discussion_notes=discussion_notes,
                terminal_commands=terminal_commands,
                commit_metadata=commit_metadata,
            )
        raise JournalParseError('Unrecognized journal entry format')

def get_journal_file_path(date, entry_type):
    """
    Return the correct journal file path based on date and entry type.
    entry_type: 'daily', 'daily_summary', 'weekly_summary', 'monthly_summary', 'yearly_summary'
    """
    if entry_type == "daily":
        return Path("journal/daily") / f"{date}-journal.md"
    elif entry_type == "daily_summary":
        return Path("journal/summaries/daily") / f"{date}-daily.md"
    elif entry_type == "weekly_summary":
        return Path("journal/summaries/weekly") / f"{date}-weekly.md"
    elif entry_type == "monthly_summary":
        return Path("journal/summaries/monthly") / f"{date}-monthly.md"
    elif entry_type == "yearly_summary":
        return Path("journal/summaries/yearly") / f"{date}-yearly.md"
    else:
        raise ValueError(f"Unknown entry_type: {entry_type}")

def create_journal_directories(base_dir):
    """
    Create all required journal subdirectories under base_dir.
    """
    (Path(base_dir) / "daily").mkdir(parents=True, exist_ok=True)
    (Path(base_dir) / "summaries" / "daily").mkdir(parents=True, exist_ok=True)
    (Path(base_dir) / "summaries" / "weekly").mkdir(parents=True, exist_ok=True)
    (Path(base_dir) / "summaries" / "monthly").mkdir(parents=True, exist_ok=True)
    (Path(base_dir) / "summaries" / "yearly").mkdir(parents=True, exist_ok=True)

def append_to_journal_file(entry, file_path):
    """
    Append a journal entry to the file at file_path. If the file does not exist, create it.
    If the file exists and is not empty, prepend a horizontal rule (---) before the new entry.
    Automatically create parent directories as needed.
    Raises ValueError if the file path is invalid or cannot be written to.
    """
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        if file_path.exists() and file_path.stat().st_size > 0:
            with open(file_path, "a", encoding="utf-8") as f:
                f.write("\n---\n" + entry)
        else:
            with open(file_path, "a", encoding="utf-8") as f:
                f.write(entry)
    except OSError as e:
        raise ValueError(f"append_to_journal_file: Could not write to file {file_path}: {e}")
    except Exception as e:
        raise ValueError(f"append_to_journal_file: Unexpected error for file {file_path}: {e}")

# Section Generator: Summary
# Purpose: Generates the Summary section for a journal entry using AI.
# This function creates a narrative summary of what changed and why, using explicit developer statements and technical context from chat and git. It returns a placeholder; the AI agent is expected to execute the docstring prompt and fill in the content.
def generate_summary_section(journal_context) -> SummarySection:
    """
    AI Prompt for Summary Section Generation

    Purpose: Generate a narrative paragraph that captures the essential "story" of what changed and why, using conversational language that preserves the developer's authentic voice and technical context.

    Instructions: Extract explicit purpose statements and technical context from chat history and git changes to create a conversational summary. Focus on WHAT changed and WHY, told as a story.

    Priority for Content Sources:
    1. Explicit developer statements in chat - their own words about motivation, goals, problems
    2. Git commit messages - if they contain reasoning or context
    3. Git changes description - what actually changed in the code

    Purpose Statement Extraction:
    Look for explicit purpose statements in chat, such as:
    - "because..." / "since..." (reasoning)
    - "to fix..." / "to solve..." (problem-solving)
    - "so that..." / "in order to..." (goals)
    - "trying to..." / "attempting to..." (objectives)
    - Direct problem statements: "this is broken", "X isn't working"
    - Goal statements: "want to make Y easier", "need to improve Z"

    Evolution of Thinking:
    If you find multiple purpose statements that evolved over time, show the progression:
    "Started to [initial goal] but [what changed understanding] so [final approach]"

    Adaptive Story Detail:
    Match the narrative detail to what the commit actually accomplished. For example:
    - Large architectural changes might focus on high-level goals and system-wide impact
    - Focused bug fixes might tell the story of problem discovery and solution approach
    - Feature additions might explain user needs and implementation decisions
    - Refactoring might describe why cleanup was needed and what improved

    Language Translation Guidelines:
    When using developer's emotional language from chat and commit messages, translate respectfully:
    - Preserve authentic emotional expression including colorful language
    - Translate unkind language towards others into neutral descriptions, including:
      - Personal attacks or harsh judgments about individuals
      - Racism, sexism, or negative bias based on gender, sexual orientation, religion, etc.
      - Mean statements about people's abilities or worth
    - Preserve positive "who I am" language and translate only negative self-talk
    - Examples:
      - Keep: "this f***ing bug is driving me crazy", "I am awesome!", "I nailed that implementation"
      - Translate: "I'm such an idiot" → "encountered challenging complexity", "Bob writes terrible code" → "encountered challenging legacy implementation"

    ANTI-HALLUCINATION RULES:
    - Do NOT invent, infer, or summarize information not explicitly present in the context
    - Only include purpose statements directly supported by chat transcript or commit messages
    - If developer hasn't stated WHY something was done, describe WHAT was done without guessing motivation
    - If chat context is unavailable, work only with git changes - do not speculate about reasons

    Output Format:
    Single paragraph, conversational tone, any length needed to tell the complete story.

    CHECKLIST:
    - [ ] Searched chat history for explicit purpose statements using keyword patterns
    - [ ] Extracted developer's actual reasoning where explicitly stated
    - [ ] Showed evolution of thinking if multiple purposes emerged over time
    - [ ] Translated harsh personal language while preserving technical meaning and authentic frustration
    - [ ] Used git changes as foundation when chat context unavailable
    - [ ] Did NOT infer or speculate about unstated motivations
    - [ ] Created conversational narrative that explains what changed and why
    - [ ] Preserved authentic technical voice through respectful translation
    - [ ] Included technical context in story-telling format
    - [ ] Verified all content is grounded in actual chat/git evidence
    """
    return SummarySection(summary="")

# Section Generator: Technical Synopsis
# TechnicalSynopsisSection: Represents the technical synopsis section of a journal entry.
# This section provides a code-focused analysis of what changed, generated by an AI-driven function pattern.
# The function returns a placeholder; the AI agent is expected to execute the docstring prompt and fill in the content.
def generate_technical_synopsis_section(journal_context: JournalContext) -> TechnicalSynopsisSection:
    """
    AI Prompt for Technical Synopsis Section Generation

    Purpose: Generate a code-focused analysis of what changed in this commit, providing technical implementation details that complement the narrative summary.

    Instructions: Extract technical implementation details from chat history and git changes to create a precise synopsis of how the work was accomplished. Focus on architectural patterns, code structure changes, technical approaches, and implementation specifics.

    Priority for Content Sources:
    1. Explicit technical details from chat - developer's own words about implementation approach
    2. Git commit messages - if they contain technical reasoning
    3. Git changes description - what actually changed in the code
    4. Terminal commands - to add technical context when relevant

    Technical Detail Extraction:
    Look for any explicit technical discussion about implementation, including:
    - Architectural patterns and design decisions
    - Specific classes, functions, modules, or files modified
    - Technical approaches and methodologies used
    - Technology stack changes or additions
    - Code structure and organization changes
    - Testing strategies and implementation
    - Performance considerations
    - Integration approaches

    Adaptive Detail Level:
    Match the detail level to what the commit actually changed. For example:
    - Large architectural changes might focus on high-level patterns and system design
    - Focused bug fixes might describe specific technical solutions and root causes
    - Feature additions might detail implementation approach and integration points
    - Refactoring might explain structural improvements and code organization changes

    Language Translation Guidelines:
    When using developer's emotional language from chat and commit messages, translate respectfully:
    - Preserve authentic emotional expression including colorful language
    - Translate unkind language towards others into neutral descriptions, including:
      - Personal attacks or harsh judgments about individuals
      - Racism, sexism, or negative bias based on gender, sexual orientation, religion, etc.
      - Mean statements about people's abilities or worth
    - Preserve positive "who I am" language and translate only negative self-talk
    - Examples:
      - Keep: "this f***ing bug is driving me crazy", "I am awesome!", "I nailed that implementation"
      - Translate: "I'm such an idiot" → "encountered challenging complexity", "Bob writes terrible code" → "encountered challenging legacy implementation"

    ANTI-HALLUCINATION RULES:
    - Do NOT invent, infer, or summarize technical information not explicitly present in the context
    - Only include technical details directly supported by chat transcript, commit messages, or git changes
    - If developer hasn't explained HOW something was implemented, describe only WHAT changed based on available evidence
    - If chat context is unavailable, work only with git changes - do not speculate about implementation approaches
    - Never assume what code changes "probably" accomplish technically

    Output Format:
    Self-contained technical narrative, any length needed to tell the complete technical story. Multiple paragraphs allowed for complex changes. No cross-references to other sections.

    CHECKLIST:
    - [ ] Searched chat history for explicit technical implementation details
    - [ ] Extracted developer's actual technical reasoning where explicitly stated
    - [ ] Adapted detail level to match commit scope and available information
    - [ ] Translated harsh personal language while preserving technical meaning and authentic frustration
    - [ ] Used git changes as foundation when chat context unavailable
    - [ ] Did NOT infer or speculate about technical approaches not explicitly described
    - [ ] Created self-contained technical narrative without cross-references
    - [ ] Preserved authentic technical voice through respectful translation
    - [ ] Included relevant technical context from terminal commands when available
    - [ ] Verified all technical content is grounded in actual chat/git/terminal evidence
    """
    # Returns a placeholder. The AI agent is expected to execute the docstring prompt and fill in the content.
    return TechnicalSynopsisSection(technical_synopsis="")

# Section Generator: Accomplishments
# Purpose: Extracts and summarizes what was successfully completed or achieved in the commit, focusing on developer satisfaction and explicit evidence from chat and git context.
# Assumptions: Only includes accomplishments with clear evidence; does not infer or speculate. Returns an empty list if nothing is found.
# Limitations: Requires AI agent to fulfill the docstring prompt; placeholder implementation returns empty list.
def generate_accomplishments_section(journal_context: JournalContext) -> AccomplishmentsSection:
    """
    AI Prompt for Accomplishments Section Generation

    Purpose: Generate a list of what was successfully completed or achieved in this commit, capturing the developer's authentic sense of accomplishment and satisfaction with their work.

    Instructions: Extract evidence of successful completion and developer satisfaction from chat history and git changes to create a list of meaningful accomplishments. Focus on what the developer felt good about, what was successfully resolved, and what meaningful progress was made.

    Priority for Content Sources:
    1. Explicit pride/satisfaction statements from chat - developer's own expressions of accomplishment
    2. Completion language - clear indicators of successful finishing or resolution
    3. Problem resolution statements - evidence of issues being solved
    4. Git changes - what was actually completed based on code changes

    Accomplishment Evidence Extraction:
    Look for explicit indicators of success and satisfaction, such as:
    - Pride/satisfaction expressions: "finally got this working", "that was satisfying", "so glad I figured that out"
    - Completion language: "finished the refactor", "got the tests passing", "deployed successfully"
    - Problem resolution: "fixed the bug", "resolved the issue", "got it working"
    - Relief/breakthrough moments: "breakthrough!", "finally!", "that did it"
    - Positive self-assessment: "this turned out well", "happy with this solution"

    Energy Level Matching:
    Match the developer's energy level about each achievement:
    - High excitement/satisfaction → convey that energy in the accomplishment description
    - Matter-of-fact completion → stay neutral and straightforward
    - Relieved resolution → acknowledge the effort or challenge overcome
    - Proud technical achievement → highlight the significance appropriately

    Adaptive Grouping and Detail:
    - Light/related changes: Group together if they feel like one cohesive accomplishment
    - Significant distinct achievements: List separately to give each proper recognition
    - Detail level: Adapt based on available context and significance
      - Just the achievement: "Fixed authentication timeout issues"
      - Achievement + context: "Fixed authentication timeout issues affecting user login"
      - Achievement + effort: "Fixed authentication timeout issues after extensive debugging"

    Include Both Accomplishment and Concerns:
    When developer expresses both accomplishment and self-criticism, include both:
    - "Finally got this working but it's probably terrible code" → "Successfully resolved implementation challenges despite code quality concerns"
    - Preserve both the achievement AND the developer's honest assessment
    - Negativity and concerns are important feedback about the work

    Language Translation Guidelines:
    When using developer's emotional language from chat and commit messages, translate respectfully:
    - Preserve authentic emotional expression including colorful language
    - Translate unkind language towards others into neutral descriptions, including:
      - Personal attacks or harsh judgments about individuals
      - Racism, sexism, or negative bias based on gender, sexual orientation, religion, etc.
      - Mean statements about people's abilities or worth
    - Preserve positive "who I am" language and translate only negative self-talk
    - Examples:
      - Keep: "this f***ing bug is driving me crazy", "I am awesome!", "I nailed that implementation"
      - Translate: "I'm such an idiot" → "encountered challenging complexity", "Bob writes terrible code" → "encountered challenging legacy implementation"

    ANTI-HALLUCINATION RULES:
    - Do NOT invent, infer, or assume accomplishments not explicitly indicated by evidence
    - Only include accomplishments supported by developer satisfaction/completion language in chat or clear git evidence
    - Never infer that something was "accomplished" just because code changed
    - If developer expressed frustration about something, don't list it as accomplishment even if git shows completion
    - If no explicit satisfaction/completion language exists, work only with clear git evidence of completion

    Output Format:
    Complete sentences in bullet point format with blank lines between items. Include however many accomplishments feel meaningful for this commit - could be one major achievement or several smaller ones.

    CHECKLIST:
    - [ ] Searched chat history for explicit pride, satisfaction, and completion language
    - [ ] Prioritized developer's own sense of accomplishment over external measures
    - [ ] Matched energy level of developer's expressed satisfaction with each achievement
    - [ ] Grouped related accomplishments when they feel cohesive, separated when distinct
    - [ ] Included both achievements and any concerns/criticisms expressed alongside them
    - [ ] Used complete sentences for clarity and professional reusability
    - [ ] Translated harsh personal language while preserving authentic enthusiasm and technical meaning
    - [ ] Did NOT infer accomplishments not supported by explicit evidence
    - [ ] Verified all accomplishments are grounded in actual developer satisfaction or clear completion evidence
    - [ ] Adapted detail level based on significance and available context
    """
    return AccomplishmentsSection(accomplishments=[])

# Section Generator: Frustrations
# Purpose: Extracts and summarizes challenges, setbacks, and frustrations encountered in the commit, using only explicit evidence from chat, terminal, and git context.
# Assumptions: Only includes frustrations with clear evidence; does not infer or speculate. Returns an empty list if nothing is found.
# Limitations: Requires AI agent to fulfill the docstring prompt; placeholder implementation returns empty list.
def generate_frustrations_section(journal_context: JournalContext) -> FrustrationsSection:
    """
    AI Prompt for Frustrations or Roadblocks Section Generation

    Purpose: Generate a list of challenges, setbacks, and frustrations encountered during this commit, capturing the developer's authentic experience of difficulties and obstacles faced during the work.

    Instructions: Extract evidence of frustrations, problems, and roadblocks from chat history and git changes to create a list of meaningful challenges. Focus on what the developer found difficult, what caused problems, and what created obstacles during the work.

    Priority for Content Sources:
    1. Explicit frustration expressions from chat - developer's own expressions of difficulty and challenge
    2. Problem/challenge statements - clear indicators of issues encountered
    3. Failed attempts or setbacks - evidence of approaches that didn't work
    4. Git/terminal evidence - multiple attempts, rollbacks, or repeated changes indicating difficulty

    Frustration Evidence Extraction:
    Look for explicit indicators of difficulty and challenges, such as:
    - Frustration expressions: "this is driving me crazy", "can't figure this out", "hitting a wall here"
    - Problem statements: "this isn't working", "running into issues with X", "stuck on this bug"
    - Failed attempts: "tried X but it didn't work", "had to rollback", "that approach failed"
    - Challenge acknowledgments: "this is harder than expected", "complex problem", "tricky issue"
    - Persistence indicators: "still struggling with", "keep hitting", "multiple attempts"

    Include Everything:
    Capture the full developer experience including:
    - Pure roadblocks that remained unresolved
    - Frustrations that were eventually resolved
    - Partial progress and ongoing challenges
    - Multiple attempts and iterative problem-solving
    - Failed approaches and what was learned

    Energy Level Matching:
    Match the developer's frustration intensity level:
    - High frustration → convey that intensity: "Encountered persistent, challenging issues with..."
    - Mild annoyance → stay proportional: "Ran into some complications with..."
    - Matter-of-fact problems → neutral tone: "Addressed technical challenges in..."

    Resolution Status:
    Include whether issues were resolved or remain ongoing:
    - Resolved: "Encountered authentication timeout issues - eventually resolved through connection pooling"
    - Ongoing: "Hit persistent database performance problems - still investigating solutions"
    - Partial: "Struggled with complex merge conflicts - partially resolved but some edge cases remain"

    Adaptive Grouping:
    - Related frustrations: Group together if they feel like one big frustrating problem
    - Distinct roadblocks: List separately to give each proper recognition
    - Adaptive detail: Match detail level to significance and available context

    Language Translation Guidelines:
    When using developer's emotional language from chat and commit messages, translate respectfully:
    - Preserve authentic emotional expression including colorful language
    - Translate unkind language towards others into neutral descriptions, including:
      - Personal attacks or harsh judgments about individuals
      - Racism, sexism, or negative bias based on gender, sexual orientation, religion, etc.
      - Mean statements about people's abilities or worth
    - Preserve positive "who I am" language and translate only negative self-talk
    - Examples:
      - Keep: "this f***ing bug is driving me crazy", "I am awesome!", "I nailed that implementation"
      - Translate: "I'm such an idiot" → "encountered challenging complexity", "Bob writes terrible code" → "encountered challenging legacy implementation"

    ANTI-HALLUCINATION RULES:
    - Do NOT invent, infer, or assume frustrations not explicitly indicated by evidence
    - Only include frustrations supported by developer expressions or clear evidence of difficulty
    - Never infer that something was "frustrating" just because it took multiple commits or iterations
    - If developer didn't express frustration about something, don't assume it was problematic
    - If no explicit frustration language exists, work only with clear evidence of failed attempts or setbacks

    Output Format:
    Complete sentences in bullet point format with blank lines between items. Include however many frustrations feel meaningful for this commit - could be one major roadblock or several smaller challenges.

    CHECKLIST:
    - [ ] Searched chat history for explicit frustration, challenge, and problem language
    - [ ] Included all aspects of developer frustration experience - unresolved, resolved, and ongoing
    - [ ] Matched intensity level of developer's expressed frustration with each challenge
    - [ ] Grouped related frustrations when they feel cohesive, separated when distinct
    - [ ] Included resolution status for each frustration (resolved, ongoing, partial)
    - [ ] Used complete sentences for clarity and professional reusability
    - [ ] Translated harsh personal language while preserving authentic frustration intensity and technical meaning
    - [ ] Did NOT infer frustrations not supported by explicit evidence
    - [ ] Verified all frustrations are grounded in actual developer expressions or clear evidence of difficulty
    - [ ] Adapted detail level based on significance and available context
    """
    # Frustrations Section Generator
    # Purpose: Extracts and summarizes challenges, setbacks, and frustrations encountered in the commit, using only explicit evidence from chat, terminal, and git context.
    # Assumptions: Only includes frustrations with clear evidence; does not infer or speculate. Returns an empty list if nothing is found.
    # Limitations: Requires AI agent to fulfill the docstring prompt; placeholder implementation returns empty list.
    return FrustrationsSection(frustrations=[])

# Section Generator: Tone/Mood
# Purpose: Generates the Tone/Mood section for a journal entry using AI.
# This function analyzes chat, commit, and terminal context to infer the developer's emotional state and supporting evidence. Only includes moods with explicit or strongly inferred evidence; does not speculate. Returns a placeholder until the AI agent executes the docstring prompt.
def generate_tone_mood_section(journal_context: JournalContext) -> ToneMoodSection:
    """
    AI Prompt for Tone/Mood Section Generation

    Purpose: Extract and summarize the overall mood or emotional tone of the developer during this commit, capturing both stable emotional states and emotional progressions with rich narrative context.

    Instructions: Extract explicit mood statements and emotional indicators from chat history and commit messages. Use AI's ability to detect subtle emotional cues while indicating confidence level based on evidence strength. Create both a concise mood summary with confidence level and detailed narrative context explaining the emotional experience. If there is no evidence of tone or mood, omit this section entirely.

    Priority for Content Sources:
    1. Explicit emotional statements from chat - developer's own direct expressions of mood and feeling
    2. Commit messages - explicit emotional language, frustration, satisfaction, or urgency in commit text
    3. Subtle emotional indicators - language patterns, energy shifts, confidence changes (mark as lower confidence)
    4. Behavioral patterns - persistence, breakthrough moments, response styles (mark as lower confidence)

    Mood Evidence Extraction:
    Look for explicit and subtly observable emotional indicators, such as:
    - Explicit emotions: "this is frustrating", "finally got it working!", "feeling confident about this"
    - Commit message emotion: "fix annoying bug", "finally resolve X", "ugh, another edge case", "clean up terrible code"
    - Subtle language patterns: short responses suggesting frustration, exclamation points showing excitement, energy shifts
    - Behavioral indicators: persistent attempts, giving up language, breakthrough excitement
    - Confidence shifts: uncertain language ("maybe this will work") vs. confident assertions ("this should fix it")
    - Relief/satisfaction: "phew", "thank god", "that was satisfying"
    - Determination: "let me try again", "not giving up on this", "going to figure this out"

    Confidence Level Guidelines:
    - High confidence: Explicit emotional statements, clear emotional language in commits
    - Medium confidence: Strong behavioral patterns with some explicit language
    - Lower confidence: Subtle patterns, inferred from behavior without explicit statements

    Mood Format Guidelines:
    For stable moods: Single descriptive phrase with confidence level ("Focused and methodical (high confidence)")
    For progressive moods: Timeline format with arrows and confidence level ("Frustrated → determined → relieved (high confidence)")

    Indicators Format Guidelines:
    For stable moods: Narrative explanation with supporting evidence and quotes
    For progressive moods: Rich narrative context explaining transitions between emotional states, including:
    - What technical events triggered emotional changes
    - Specific quotes supporting each emotional phase (from both chat and commit messages)
    - Causal connections between work progress and emotional responses
    - Clear indication of evidence type (explicit vs. inferred)

    Adaptive Detail Level:
    Match the detail to the available emotional evidence:
    - Rich emotional context: Full narrative with multiple quotes and transitions
    - Moderate emotional context: Brief narrative with key supporting evidence
    - Minimal emotional context: Simple mood description with basic indicators
    - No emotional evidence: Return empty strings for both fields and omit section

    Language Translation Guidelines:
    When using developer's emotional language from chat and commit messages, translate respectfully:
    - Preserve authentic emotional expression including colorful language
    - Translate unkind language towards others into neutral descriptions, including:
      - Personal attacks or harsh judgments about individuals
      - Racism, sexism, or negative bias based on gender, sexual orientation, religion, etc.
      - Mean statements about people's abilities or worth
    - Preserve positive "who I am" language and translate only negative self-talk
    - Examples:
      - Keep: "this f***ing bug is driving me crazy", "I am awesome!", "I nailed that implementation"
      - Translate: "I'm such an idiot" → "encountered challenging complexity", "Bob writes terrible code" → "encountered challenging legacy implementation"

    ANTI-HALLUCINATION RULES:
    - Do NOT infer, assume, or speculate about emotional states without supporting evidence
    - Always indicate confidence level based on evidence strength
    - Be explicit about whether emotions are stated directly or inferred from patterns
    - Never assume emotions based solely on work difficulty, success, failure, or technical complexity
    - If there is no evidence of tone or mood, return empty strings and omit this section entirely

    Output Format:
    - mood: Concise emotional state or progression with confidence level in parentheses (omit if no evidence)
    - indicators: Rich narrative context explaining the emotional experience with specific evidence and quotes (omit if no evidence)
    - If mood has content but indicators doesn't: include only mood field
    - If indicators has content but mood doesn't: include only indicators field  
    - If both fields are empty: omit the entire Tone/Mood section
    - Return empty strings for fields that should be omitted

    CHECKLIST:
    - [ ] Searched chat history for explicit emotional statements and subtle language patterns
    - [ ] Analyzed commit messages for explicit emotional language
    - [ ] Assessed confidence level based on evidence strength (explicit vs. inferred)
    - [ ] Used timeline format with confidence level for progressions, single phrase with confidence level for stable moods
    - [ ] Created rich narrative context explaining emotional experience and transitions
    - [ ] Included specific quotes and evidence type (explicit vs. inferred) supporting each emotional state
    - [ ] Explained causal connections between technical events and emotional responses
    - [ ] Preserved authentic language while translating unkind statements toward others
    - [ ] Preserved positive self-assessment and only translated negative identity language
    - [ ] Indicated confidence level based on evidence quality
    - [ ] Verified emotional content is grounded in actual evidence with appropriate confidence assessment
    - [ ] Returned empty strings if no emotional evidence was found
    """
    return ToneMoodSection(mood="", indicators="")

# Section Generator: Discussion Notes
# Purpose: Generates the Discussion Notes section for a journal entry using AI.
# This function extracts and summarizes all relevant discussion points from chat history, focusing on technical decisions, emotions, problem-solving, and other valuable conversation that shaped the work in this commit. Only includes discussion points with explicit evidence in chat; does not paraphrase or invent content. Returns a placeholder until the AI agent executes the docstring prompt.
def generate_discussion_notes_section(journal_context: JournalContext) -> DiscussionNotesSection:
    """
    AI Prompt for Discussion Notes Section Generation

    Purpose: Extract and summarize all relevant discussion points from chat history, focusing on technical decisions, emotions, problem-solving, and other valuable conversation that shaped the work in this commit.

    Instructions: Extract discussion points from chat history in chronological order, focusing on content that provides insight into the technical work and decision-making process. Include speaker attribution when possible, preserve conversational flow, and apply appropriate content filtering and length limits.

    Priority for Content Sources (in order of importance):
    1. Explicit mood expressions - quotes with clear emotional content
    2. Technical decisions and tradeoffs - quotes about "should we use X or Y because...", "the tradeoff here is..."
    3. Problem-solving dialogue - "what if we try Y?", "that won't work because..."
    4. Questions and clarifications that shaped the work
    5. Everything else - other relevant technical discussion

    Discussion Content Extraction:
    Focus on including content that matches these positive criteria:
    - Emotional expressions and mood indicators
    - Technical decision-making conversations and reasoning
    - Problem-solving approaches and solutions
    - Questions that led to important clarifications
    - Statements explaining motivations, goals, or constraints
    - Breakthrough moments or significant realizations
    - Any other technical discussion that provides insight into the work process

    Message Length and Content Guidelines:
    - Limit each extracted discussion note to ~100-150 words, using excerpt notation when longer messages need to be shortened
    - Include enough surrounding context to make quotes meaningful, within the ~100-150 word limit per note
    - Preserve conversational flow (related back-and-forth discussion) when it fits within word limits
    - Use `[...]` notation where content is omitted for length
    - Focus on parts that match priority types and explicit reasoning keywords ("because", "since", "the tradeoff is")

    Speaker Attribution and Formatting:
    - Always try to attribute to speaker when possible, fall back to plain string if unclear
    - Present in chronological order, grouping messages by topic with blank lines between different topics
    - Trust AI judgment to recognize natural topic boundaries and appropriate granularity
    - Preserve natural conversation flow and connections between related messages when length permits

    Language Translation Guidelines:
    When using developer's language from chat, translate respectfully:
    - Preserve authentic emotional expression including colorful language
    - Translate unkind language towards others into neutral descriptions, including:
     - Personal attacks or harsh judgments about individuals
     - Racism, sexism, or negative bias based on gender, sexual orientation, religion, etc.
     - Mean statements about people's abilities or worth
    - Preserve positive "who I am" language and translate only negative self-talk
    - Examples:
     - Keep: "this f***ing bug is driving me crazy", "I am awesome!", "I nailed that implementation"
     - Translate: "I'm such an idiot" → "encountered challenging complexity", "Bob writes terrible code" → "encountered challenging legacy implementation"

    ANTI-HALLUCINATION RULES:
    - Do NOT invent, infer, or summarize discussion points not explicitly present in the chat history
    - Only include discussion content directly supported by the chat transcript
    - Do not paraphrase or rewrite quotes - extract actual conversation content
    - If no relevant discussion is found, return an empty list and omit the section
    - Never combine separate conversations or create composite quotes

    Output Format:
    - List of strings or dicts with 'speaker' and 'text' fields for attributed quotes
    - Return empty list if no relevant discussion notes are found and omit the section
    - Maintain chronological order grouped by topic
    - Include `[...]` notation when content has been shortened

    CHECKLIST:
    - [ ] Searched chat history for content matching priority criteria (emotions, decisions, problem-solving, questions, technical discussion)
    - [ ] Extracted actual conversation content without paraphrasing or invention
    - [ ] Applied appropriate length limits with excerpt notation when needed
    - [ ] Included sufficient context to make quotes meaningful
    - [ ] Preserved conversational flow and speaker attribution when possible
    - [ ] Grouped by topic with appropriate granularity and blank lines between topics
    - [ ] Applied language translation guidelines while preserving authentic expression
    - [ ] Used only content directly supported by chat transcript
    - [ ] Returned empty list and omitted section if no relevant discussion was found
    - [ ] Did NOT invent, combine, or composite any discussion content
    """
    return DiscussionNotesSection(discussion_notes=[])

# Section Generator: Terminal Commands
# Purpose: Generates the Terminal Commands section for a journal entry using AI.
# This function extracts and lists all relevant terminal commands executed during the commit, focusing on commands that demonstrate problem-solving, technical approach, or challenges. Only includes commands with explicit evidence in terminal context; does not paraphrase or invent content. Returns a placeholder until the AI agent executes the docstring prompt.
def generate_terminal_commands_section(journal_context: JournalContext) -> TerminalCommandsSection:
    """
    AI Prompt for Terminal Commands Section Generation

    Purpose
    Extract and list all relevant terminal commands executed during this commit, focusing on commands that demonstrate problem-solving, technical approach, or challenges.

    Instructions
    Extract terminal commands from terminal context to create a chronological list of meaningful commands executed during the work session. Focus on commands that provide insight into the technical process and decision-making approach.

    Priority for Content Sources
    1. Terminal context from journal_context.terminal - the authoritative source for executed commands
    2. No other sources - work exclusively with the provided terminal context

    Terminal Command Extraction
    Look for commands that provide technical insight, such as:
    - Commands that demonstrate problem-solving steps
    - Commands that show the technical approach taken
    - Failed commands that highlight challenges or errors
    - Repetitive commands that might indicate frustrations or iteration
    - Build, test, or deployment commands that show progress
    - Debugging or investigation commands

    Filtering Guidelines
    Exclude commands that don't add narrative value:
    - Routine git commands (add, status, commit) unless they are significant to the narrative
    - Commands run specifically as part of journal entry creation or extraction
    - Commands containing passwords, API keys, tokens, or other sensitive information
    - Commands that reveal personal identifiable information (PII)
    - Basic navigation commands (cd, ls, pwd) unless part of a meaningful sequence
    - Obviously invalid commands: typos, malformed syntax, incomplete commands that add no technical insight

    Include meaningful failures that demonstrate problem-solving:
    - Commands that failed due to missing dependencies (shows environment setup process)
    - Commands that failed due to configuration issues (shows troubleshooting approach)
    - Commands that revealed errors leading to solutions (shows debugging process)
    - Failed attempts that led to successful alternatives (shows iteration and learning)

    Deduplication Rules
    - Apply adjacent identical command deduplication: compress consecutive identical commands with count notation (e.g., "npm test x3")
    - Preserve chronological order of distinct commands
    - Do not deduplicate non-adjacent commands even if identical

    ANTI-HALLUCINATION RULES
    - Do NOT invent, infer, or summarize commands that are not explicitly present in the terminal context
    - Only include commands that are directly supported by the terminal transcript
    - If no terminal context is available, return an empty list and omit the section
    - Never speculate about commands that might have been run
    - If a command is not present in the context, do NOT fill in gaps or assume it happened

    Output Format
    - List of strings, each representing a single terminal command
    - Return empty list if no relevant commands are found and omit the section
    - Maintain chronological order as they appeared in the terminal context
    - Apply deduplication formatting where appropriate (e.g., "command x3")

    CHECKLIST
    - [ ] Extracted commands exclusively from journal_context.terminal
    - [ ] Focused on commands that demonstrate problem-solving, technical approach, or challenges
    - [ ] Excluded routine git commands unless significant to the narrative
    - [ ] Excluded journal entry creation commands
    - [ ] Excluded commands containing sensitive information or PII
    - [ ] Excluded obviously invalid commands (typos, malformed syntax) while preserving meaningful failures
    - [ ] Included meaningful failures that demonstrate debugging and problem-solving process
    - [ ] Applied adjacent identical command deduplication with count notation
    - [ ] Preserved chronological order of distinct commands
    - [ ] Did NOT invent, infer, or speculate about commands not present in context
    - [ ] Returned empty list if no relevant commands found
    - [ ] Verified all commands are grounded in actual terminal context evidence
    """
    return TerminalCommandsSection(terminal_commands=[])

# Section Generator: Commit Metadata
# Purpose: Generates the Commit Metadata section for a journal entry using AI.
# This function extracts and formats relevant commit metadata from git context, providing key statistics and classifications that support the journal entry narrative. Only includes metadata fields directly supported by the git context data; does not invent or speculate. Returns a placeholder until the AI agent executes the docstring prompt.
def generate_commit_metadata_section(journal_context: JournalContext) -> CommitMetadataSection:
    """
    AI Prompt for Commit Metadata Section Generation

    Purpose: Extract and format relevant commit metadata from git context, providing key statistics and classifications that support the journal entry narrative.

    Instructions: Extract commit metadata from git context to create a clean, scannable summary of commit statistics and characteristics. Focus on metadata that provides useful context for understanding the scope and nature of the changes.

    Priority for Content Sources:
    1. Git context from journal_context.git - the authoritative source for all commit metadata
    2. No other sources - work exclusively with the provided git context

    Metadata Extraction:
    Extract and format the following metadata fields when available and meaningful:
    - **files_changed**: Total number of files modified in the commit
    - **insertions**: Total lines added
    - **deletions**: Total lines removed  
    - **size_classification**: Pre-classified commit size (small/medium/large)
    - **is_merge**: Whether this was a merge commit
    - **source_files**: Count of source code files changed
    - **config_files**: Count of configuration files changed
    - **docs_files**: Count of documentation files changed
    - **tests_files**: Count of test files changed

    Filtering Guidelines:
    Include only metadata that adds narrative value:
    - Include basic statistics (files_changed, insertions, deletions) when non-zero
    - Include size_classification and merge status when meaningful
    - Include file type counts only when non-zero and show meaningful distribution
    - Exclude metadata fields that are empty, zero, or not meaningful for this commit

    ANTI-HALLUCINATION RULES:
    - Do NOT invent, infer, or calculate metadata not explicitly present in the git context
    - Only include metadata fields directly supported by the git context data
    - If no git context is available, return an empty dict and omit the section
    - Never speculate about commit characteristics not present in the data

    Output Format:
    - Dict[str, str] with specified field names as keys and formatted values as strings
    - Return empty dict if no relevant metadata is found and omit the section
    - All values should be formatted as strings suitable for display

    CHECKLIST:
    - [ ] Extracted metadata exclusively from journal_context.git
    - [ ] Used specified field names for consistency
    - [ ] Included only meaningful/non-zero metadata fields
    - [ ] Formatted all values as display-ready strings
    - [ ] Did NOT invent, calculate, or speculate about metadata not present in git context
    - [ ] Returned empty dict if no relevant metadata found
    - [ ] Verified all metadata is grounded in actual git context data
    """
    return CommitMetadataSection(commit_metadata={})
